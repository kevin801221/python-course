## 函式使用進階

我們繼續探索定義和使用函式的相關知識。透過前面的學習，我們知道了函式有自變數（引數）和因變數（返回值），自變數可以是任意的資料型別，因變數也可以是任意的資料型別，那麼這裡就有一個小問題，我們能不能用函式作為函式的引數，用函式作為函式的返回值？這裡我們先說結論：**Python 中的函式是“一等函式”**，所謂“一等函式”指的就是函式可以賦值給變數，函式可以作為函式的引數，函式也可以作為函式的返回值。把一個函式作為其他函式的引數或返回值的用法，我們通常稱之為“高階函式”。

### 高階函式

我們回到之前講過的一個例子，設計一個函式，傳入任意多個引數，對其中`int`型別或`float`型別的元素實現求和操作。我們對之前的程式碼稍作調整，讓整個程式碼更加緊湊一些，如下所示。

```python
def calc(*args, **kwargs):
    items = list(args) + list(kwargs.values())
    result = 0
    for item in items:
        if type(item) in (int, float):
            result += item
    return result
```

如果我們希望上面的`calc`函式不僅僅可以做多個引數的求和，還可以實現更多的甚至是自定義的二元運算，我們該怎麼做呢？上面的程式碼只能求和是因為函式中使用了`+=`運算子，這使得函式跟加法運算形成了耦合關係，如果能解除這種耦合關係，函式的通用性和靈活性就會更好。解除耦合的辦法就是將`+`運算子變成函式呼叫，並將其設計為函式的引數，程式碼如下所示。

```python
def calc(init_value, op_func, *args, **kwargs):
    items = list(args) + list(kwargs.values())
    result = init_value
    for item in items:
        if type(item) in (int, float):
            result = op_func(result, item)
    return result
```

注意，上面的函式增加了兩個引數，其中`init_value`代表運算的初始值，`op_func`代表二元運算函式，為了呼叫修改後的函式，我們先定義做加法和乘法運算的函式，程式碼如下所示。

```python
def add(x, y):
    return x + y


def mul(x, y):
    return x * y
```

如果要做求和的運算，我們可以按照下面的方式呼叫`calc`函式。

```python
print(calc(0, add, 1, 2, 3, 4, 5))  # 15
```

如果要做求乘積運算，我們可以按照下面的方式呼叫`calc`函式。

```python
print(calc(1, mul, 1, 2, 3, 4, 5))  # 120 
```

上面的`calc`函式透過將運算子變成函式的引數，實現了跟加法運算耦合，這是一種非常高明和實用的程式設計技巧，但對於最初學者來說可能會覺得難以理解，建議大家細品一下。需要注意上面的程式碼中，將函式作為引數傳入其他函式和直接呼叫函式是有顯著的區別的，**呼叫函式需要在函式名後面跟上圓括號，而把函式作為引數時只需要函式名即可**。

如果我們沒有提前定義好`add`和`mul`函式，也可以使用 Python 標準庫中的`operator`模組提供的`add`和`mul`函式，它們分別代表了做加法和做乘法的二元運算，我們拿過來直接使用即可，程式碼如下所示。

```python
import operator

print(calc(0, operator.add, 1, 2, 3, 4, 5))  # 15
print(calc(1, operator.mul, 1, 2, 3, 4, 5))  # 120
```

Python 內建函式中有不少高階函式，我們前面提到過的`filter`和`map`函式就是高階函式，前者可以實現對序列中元素的過濾，後者可以實現對序列中元素的對映，例如我們要去掉一個整數列表中的奇數，並對所有的偶數求平方得到一個新的列表，就可以直接使用這兩個函式來做到，具體的做法是如下所示。

```python
def is_even(num):
    """判斷num是不是偶數"""
    return num % 2 == 0


def square(num):
    """求平方"""
    return num ** 2


old_nums = [35, 12, 8, 99, 60, 52]
new_nums = list(map(square, filter(is_even, old_nums)))
print(new_nums)  # [144, 64, 3600, 2704]
```

當然，要完成上面程式碼的功能，也可以使用列表生成式，列表生成式的做法更為簡單優雅。

```python
old_nums = [35, 12, 8, 99, 60, 52]
new_nums = [num ** 2 for num in old_nums if num % 2 == 0]
print(new_nums)  # [144, 64, 3600, 2704]
```

我們再來討論一個內建函式`sorted`，它可以實現對容器型資料型別（如：列表、字典等）元素的排序。我們之前講過`list`型別的`sort`方法，它實現了對列表元素的排序，`sorted`函式從功能上來講跟列表的`sort`方法沒有區別，但它會返回排序後的列表物件，而不是直接修改原來的列表，這一點我們稱為**函式的無副作用設計**，也就是說呼叫函式除了產生返回值以外，不會對程式的狀態或外部環境產生任何其他的影響。使用`sorted`函式排序時，可以透過高階函式的形式自定義排序的規則，我們透過下面的例子加以說明。

```python
old_strings = ['in', 'apple', 'zoo', 'waxberry', 'pear']
new_strings = sorted(old_strings)
print(new_strings)  # ['apple', 'in', 'pear', waxberry', 'zoo']
```

上面的程式碼對大家來說並不陌生，但是如果希望根據字串的長度而不是字母表順序對列表元素排序，我們可以向`sorted`函式傳入一個名為`key`的引數，將`key`引數賦值為獲取字串長度的函式`len`，這個函式我們在之前的課程中講到過，程式碼如下所示。

```python
old_strings = ['in', 'apple', 'zoo', 'waxberry', 'pear']
new_strings = sorted(old_strings, key=len)
print(new_strings)  # ['in', 'zoo', 'pear', 'apple', 'waxberry']
```

> **說明**：列表型別的`sort`方法也有同樣的`key`引數，有興趣的讀者可以自行嘗試。

### Lambda函式

在使用高階函式的時候，如果作為引數或者返回值的函式本身非常簡單，一行程式碼就能夠完成，也不需要考慮對函式的複用，那麼我們可以使用 lambda 函式。Python 中的 lambda 函式是沒有的名字函式，所以很多人也把它叫做**匿名函式**，lambda 函式只能有一行程式碼，程式碼中的表示式產生的運算結果就是這個匿名函式的返回值。之前的程式碼中，我們寫的`is_even`和`square`函式都只有一行程式碼，我們可以考慮用 lambda 函式來替換掉它們，程式碼如下所示。

```python
old_nums = [35, 12, 8, 99, 60, 52]
new_nums = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, old_nums)))
print(new_nums)  # [144, 64, 3600, 2704]
```

透過上面的程式碼可以看出，定義 lambda 函式的關鍵字是`lambda`，後面跟函式的引數，如果有多個引數用逗號進行分隔；冒號後面的部分就是函式的執行體，通常是一個表示式，表示式的運算結果就是 lambda 函式的返回值，不需要寫`return` 關鍵字。

前面我們說過，Python 中的函式是“一等函式”，函式是可以直接賦值給變數的。在學習了 lambda 函式之後，前面我們寫過的一些函式就可以用一行程式碼來實現它們了，大家可以看看能否理解下面的求階乘和判斷素數的函式。

```python
import functools
import operator

# 用一行程式碼實現計算階乘的函式
fac = lambda n: functools.reduce(operator.mul, range(2, n + 1), 1)

# 用一行程式碼實現判斷素數的函式
is_prime = lambda x: all(map(lambda f: x % f, range(2, int(x ** 0.5) + 1)))

# 呼叫Lambda函式
print(fac(6))        # 720
print(is_prime(37))  # True
```

> **提示1**：上面使用的`reduce`函式是 Python 標準庫`functools`模組中的函式，它可以實現對一組資料的歸約操作，類似於我們之前定義的`calc`函式，第一個引數是代表運算的函式，第二個引數是運算的資料，第三個引數是運算的初始值。很顯然，`reduce`函式也是高階函式，它和`filter`函式、`map`函式一起構成了處理資料中非常關鍵的三個動作：**過濾**、**對映**和**歸約**。
>
> **提示2**：上面判斷素數的 lambda 函式透過`range`函式構造了從 2 到 $\small{\sqrt{x}}$ 的範圍，檢查這個範圍有沒有`x`的因子。`all`函式也是 Python 內建函式，如果傳入的序列中所有的布林值都是`True`，`all`函式返回`True`，否則`all`函式返回`False`。

### 偏函式

偏函式是指固定函式的某些引數，生成一個新的函式，這樣就無需在每次呼叫函式時都傳遞相同的引數。在 Python 語言中，我們可以使用`functools`模組的`partial`函式來建立偏函式。例如，`int`函式在預設情況下可以將字串視為十進位制整數進行型別轉換，如果我們修修改它的`base`引數，就可以定義出三個新函式，分別用於將二進位制、八進位制、十六進位制字串轉換為整數，程式碼如下所示。

```python
import functools

int2 = functools.partial(int, base=2)
int8 = functools.partial(int, base=8)
int16 = functools.partial(int, base=16)

print(int('1001'))    # 1001

print(int2('1001'))   # 9
print(int8('1001'))   # 513
print(int16('1001'))  # 4097
```

不知大家是否注意到，`partial`函式的第一個引數和返回值都是函式，它將傳入的函式處理成一個新的函式返回。透過構造偏函式，我們可以結合實際的使用場景將原函式變成使用起來更為便捷的新函式，不知道大家有沒有覺得這波操作很有意思。

###  總結

Python 中的函式是一等函式，可以賦值給變數，也可以作為函式的引數和返回值，這也就意味著我們可以在 Python 中使用高階函式。高階函式的概念對新手並不友好，但它卻帶來了函式設計上的靈活性。如果我們要定義的函式非常簡單，只有一行程式碼，而且不需要函式名來複用它，我們可以使用 lambda 函式。

