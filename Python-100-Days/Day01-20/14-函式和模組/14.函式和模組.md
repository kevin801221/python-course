## 函式和模組

在講解本節課的內容之前，我們先來研究一道數學題，請說出下面的方程有多少組正整數解。

$$
x_{1} + x_{2} + x_{3} + x_{4} = 8
$$

你可能已經想到了，這個問題其實等同於將 8 個蘋果分成四組且每組至少一個蘋果有多少種方案，也等價於在分隔 8 個蘋果的 7 個間隙之間放入三個隔斷將蘋果分成四組有多少種方案，所以答案是 $\small{C_{7}^{3} = 35}$ ，其中 $\small{C_{7}^{3}}$ 代表 7 選 3 的組合數，其計算公式如下所示。

$$
C_m^n = \frac {m!} {n!(m-n)!}
$$

根據之前學習的知識，我們可以用迴圈做累乘的方式分別計算出 $\small{m!}$ 、 $\small{n!}$ 和 $\small{(m-n)!}$ ，然後再透過除法運算得到組合數 $\small{C_{m}^{n}}$ ，程式碼如下所示。

```python
"""
輸入m和n，計算組合數C(m,n)的值

Version: 1.0
Author: Kevin
"""

m = int(input('m = '))
n = int(input('n = '))
# 計算m的階乘
fm = 1
for num in range(1, m + 1):
    fm *= num
# 計算n的階乘
fn = 1
for num in range(1, n + 1):
    fn *= num
# 計算m-n的階乘
fk = 1
for num in range(1, m - n + 1):
    fk *= num
# 計算C(M,N)的值
print(fm // fn // fk)
```

輸入：

```
m = 7
n = 3
```

輸出：

```
35
```

不知大家是否注意到，上面的程式碼中我們做了三次求階乘的操作，雖然 $\small{m}$ 、 $\small{n}$ 、 $\small{m - n}$ 的值各不相同，但是三段程式碼並沒有實質性的區別，屬於重複程式碼。世界級的程式設計大師*Martin Fowler*曾經說過：“**程式碼有很多種壞味道，重複是最壞的一種！**”。要寫出高質量的程式碼，首先就要解決重複程式碼的問題。對於上面的程式碼來說，我們可以將求階乘的功能封裝到一個稱為“函式”的程式碼塊中，在需要計算階乘的地方，我們只需“呼叫函式”即可實現對求階乘功能的複用。

### 定義函式

數學上的函式通常形如 $\small{y = f(x)}$ 或者 $\small{z = g(x, y)}$ 這樣的形式，在 $\small{y = f(x)}$ 中， $\small{f}$ 是函式的名字， $\small{x}$ 是函式的自變數， $\small{y}$ 是函式的因變數；而在 $\small{z = g(x, y)}$ 中， $\small{g}$ 是函式名， $\small{x}$ 和 $\small{y}$ 是函式的自變數， $\small{z}$ 是函式的因變數。Python 中的函式跟這個結構是一致的，每個函式都有自己的名字、自變數和因變數。我們通常把 Python 函式的自變數稱為函式的引數，而因變數稱為函式的返回值。

Python 中可以使用`def`關鍵字來定義函式，和變數一樣每個函式也應該有一個漂亮的名字，命名規則跟變數的命名規則是一樣的（大家趕緊想想我們之前講過的變數的命名規則）。在函式名後面的圓括號中可以設定函式的引數，也就是我們剛才說的函式的自變數，而函式執行完成後，我們會透過`return`關鍵字來返回函式的執行結果，這就是我們剛才說的函式的因變數。如果函式中沒有`return`語句，那麼函式會返回代表空值的`None`。另外，函式也可以沒有自變數（引數），但是函式名後面的圓括號是必須有的。一個函式要做的事情（要執行的程式碼），是透過程式碼縮排的方式放到函式定義行之後，跟之前分支和迴圈結構的程式碼塊類似，如下圖所示。

<img src="../res/day14/function_definition.png" style="zoom:45%;">

下面，我們將之前程式碼中求階乘的操作放到一個函式中，透過這種方式來重構上面的程式碼。**所謂重構，是在不影響程式碼執行結果的前提下對程式碼的結構進行調整**，重構之後的程式碼如下所示。

```python
"""
輸入m和n，計算組合數C(m,n)的值

Version: 1.1
Author: Kevin
"""


# 透過關鍵字def定義求階乘的函式
# 自變數（引數）num是一個非負整數
# 因變數（返回值）是num的階乘
def fac(num):
    result = 1
    for n in range(2, num + 1):
        result *= n
    return result


m = int(input('m = '))
n = int(input('n = '))
# 計算階乘的時候不需要寫重複的程式碼而是直接呼叫函式
# 呼叫函式的語法是在函式名後面跟上圓括號並傳入引數
print(fac(m) // fac(n) // fac(m - n))
```

大家可以感受下，上面的程式碼是不是比之前的版本更加簡單優雅。更為重要的是，我們定義的求階乘函式`fac`還可以在其他需要求階乘的程式碼中重複使用。所以，**使用函式可以幫助我們將功能上相對獨立且會被重複使用的程式碼封裝起來**，當我們需要這些的程式碼，不是把重複的程式碼再編寫一遍，而是**透過呼叫函式實現對既有程式碼的複用**。事實上，Python 標準庫的`math`模組中，已經有一個名為`factorial`的函式實現了求階乘的功能，我們可以直接用`import math`匯入`math`模組，然後使用`math.factorial`來呼叫求階乘的函式；我們也可以透過`from math import factorial`直接匯入`factorial`函式來使用它，程式碼如下所示。

```python
"""
輸入m和n，計算組合數C(m,n)的值

Version: 1.2
Author: Kevin
"""
from math import factorial

m = int(input('m = '))
n = int(input('n = '))
print(factorial(m) // factorial(n) // factorial(m - n))
```

將來我們使用的函式，要麼是自定義的函式，要麼是 Python 標準庫或者三方庫中提供的函式，如果已經有現成的可用的函式，我們就沒有必要自己去定義，“**重複發明輪子**”是一件非常糟糕的事情。對於上面的程式碼，如果你覺得`factorial`這個名字太長，書寫程式碼的時候不是特別方便，我們在匯入函式的時候還可以透過`as`關鍵字為其別名。在呼叫函式的時候，我們可以用函式的別名，而不再使用它之前的名字，程式碼如下所示。

```python
"""
輸入m和n，計算組合數C(m,n)的值

Version: 1.3
Author: Kevin
"""
from math import factorial as f

m = int(input('m = '))
n = int(input('n = '))
print(f(m) // f(n) // f(m - n))
```

### 函式的引數

#### 位置引數和關鍵字引數

我們再來寫一個函式，根據給出的三條邊的長度判斷是否可以構成三角形，如果可以構成三角形則返回`True`，否則返回`False`，程式碼如下所示。

```python
def make_judgement(a, b, c):
    """判斷三條邊的長度能否構成三角形"""
    return a + b > c and b + c > a and a + c > b
```

上面`make_judgement`函式有三個引數，這種引數叫做位置引數，在呼叫函式時通常按照從左到右的順序依次傳入，而且傳入引數的數量必須和定義函式時引數的數量相同，如下所示。

```python
print(make_judgement(1, 2, 3))  # False
print(make_judgement(4, 5, 6))  # True
```

如果不想按照從左到右的順序依次給出`a`、`b`、`c` 三個引數的值，也可以使用關鍵字引數，透過“引數名=引數值”的形式為函式傳入引數，如下所示。

```python
print(make_judgement(b=2, c=3, a=1))  # False
print(make_judgement(c=6, b=4, a=5))  # True
```

在定義函式時，我們可以在引數列表中用`/`設定**強制位置引數**（*positional-only arguments*），用`*`設定**命名關鍵字引數**。所謂強制位置引數，就是呼叫函式時只能按照引數位置來接收引數值的引數；而命名關鍵字引數只能透過“引數名=引數值”的方式來傳遞和接收引數，大家可以看看下面的例子。

```python
# /前面的引數是強制位置引數
def make_judgement(a, b, c, /):
    """判斷三條邊的長度能否構成三角形"""
    return a + b > c and b + c > a and a + c > b


# 下面的程式碼會產生TypeError錯誤，錯誤資訊提示“強制位置引數是不允許給出引數名的”
# TypeError: make_judgement() got some positional-only arguments passed as keyword arguments
# print(make_judgement(b=2, c=3, a=1))
```

> **說明**：強制位置引數是 Python 3.8 引入的新特性，在使用低版本的 Python 直譯器時需要注意。

```python
# *後面的引數是命名關鍵字引數
def make_judgement(*, a, b, c):
    """判斷三條邊的長度能否構成三角形"""
    return a + b > c and b + c > a and a + c > b


# 下面的程式碼會產生TypeError錯誤，錯誤資訊提示“函式沒有位置引數但卻給了3個位置引數”
# TypeError: make_judgement() takes 0 positional arguments but 3 were given
# print(make_judgement(1, 2, 3))
```

#### 引數的預設值

Python 中允許函式的引數擁有預設值，我們可以把之前講過的一個例子“CRAPS賭博遊戲”（《第07課：分支和迴圈結構的應用》）中搖色子獲得點數的功能封裝到函式中，程式碼如下所示。

```python
from random import randrange


# 定義搖色子的函式
# 函式的自變數（引數）n表示色子的個數，預設值為2
# 函式的因變數（返回值）表示搖n顆色子得到的點數
def roll_dice(n=2):
    total = 0
    for _ in range(n):
        total += randrange(1, 7)
    return total


# 如果沒有指定引數，那麼n使用預設值2，表示搖兩顆色子
print(roll_dice())
# 傳入引數3，變數n被賦值為3，表示搖三顆色子獲得點數
print(roll_dice(3))
```

我們再來看一個更為簡單的例子。

```python
def add(a=0, b=0, c=0):
    """三個數相加求和"""
    return a + b + c


# 呼叫add函式，沒有傳入引數，那麼a、b、c都使用預設值0
print(add())         # 0
# 呼叫add函式，傳入一個引數，該引數賦值給變數a, 變數b和c使用預設值0
print(add(1))        # 1
# 呼叫add函式，傳入兩個引數，分別賦值給變數a和b，變數c使用預設值0
print(add(1, 2))     # 3
# 呼叫add函式，傳入三個引數，分別賦值給a、b、c三個變數
print(add(1, 2, 3))  # 6
```

需要注意的是，**帶預設值的引數必須放在不帶預設值的引數之後**，否則將產生`SyntaxError`錯誤，錯誤訊息是：`non-default argument follows default argument`，翻譯成中文的意思是“沒有預設值的引數放在了帶預設值的引數後面”。

#### 可變引數

Python 語言中可以透過星號表示式語法讓函式支援可變引數。所謂可變引數指的是在呼叫函式時，可以向函式傳入`0`個或任意多個引數。將來我們以團隊協作的方式開發商業專案時，很有可能要設計函式給其他人使用，但有的時候我們並不知道函式的呼叫者會向該函式傳入多少個引數，這個時候可變引數就能派上用場。

下面的程式碼演示瞭如何使用可變位置引數實現對任意多個數求和的`add`函式，呼叫函式時傳入的引數會儲存到一個元組，透過對該元組的遍歷，可以獲取傳入函式的引數。

```python
# 用星號表示式來表示args可以接收0個或任意多個引數
# 呼叫函式時傳入的n個引數會組裝成一個n元組賦給args
# 如果一個引數都沒有傳入，那麼args會是一個空元組
def add(*args):
    total = 0
    # 對儲存可變引數的元組進行迴圈遍歷
    for val in args:
        # 對引數進行了型別檢查（數值型的才能求和）
        if type(val) in (int, float):
            total += val
    return total


# 在呼叫add函式時可以傳入0個或任意多個引數
print(add())         # 0
print(add(1))        # 1
print(add(1, 2, 3))  # 6
print(add(1, 2, 'hello', 3.45, 6))  # 12.45
```

如果我們希望透過“引數名=引數值”的形式傳入若干個引數，具體有多少個引數也是不確定的，我們還可以給函式新增可變關鍵字引數，把傳入的關鍵字引數組裝到一個字典中，程式碼如下所示。

```python
# 引數列表中的**kwargs可以接收0個或任意多個關鍵字引數
# 呼叫函式時傳入的關鍵字引數會組裝成一個字典（引數名是字典中的鍵，引數值是字典中的值）
# 如果一個關鍵字引數都沒有傳入，那麼kwargs會是一個空字典
def foo(*args, **kwargs):
    print(args)
    print(kwargs)


foo(3, 2.1, True, name='Kevin', age=43, gpa=4.95)
```

輸出：

```
(3, 2.1, True)
{'name': 'Kevin', 'age': 43, 'gpa': 4.95}
```

### 用模組管理函式

不管用什麼樣的程式語言來寫程式碼，給變數、函式起名字都是一個讓人頭疼的問題，因為我們會遇到**命名衝突**這種尷尬的情況。最簡單的場景就是在同一個`.py`檔案中定義了兩個同名的函式，如下所示。

```python
def foo():
    print('hello, world!')


def foo():
    print('goodbye, world!')

    
foo()  # 大家猜猜呼叫foo函式會輸出什麼
```

當然上面的這種情況我們很容易就能避免，但是如果專案是團隊協作多人開發的時候，團隊中可能有多個程式設計師都定義了名為`foo`的函式，這種情況下怎麼解決命名衝突呢？答案其實很簡單，Python 中每個檔案就代表了一個模組（module），我們在不同的模組中可以有同名的函式，在使用函式的時候，我們透過`import`關鍵字匯入指定的模組再使用**完全限定名**（`模組名.函式名`）的呼叫方式，就可以區分到底要使用的是哪個模組中的`foo`函式，程式碼如下所示。

`module1.py`

```python
def foo():
    print('hello, world!')
```

`module2.py`

```python
def foo():
    print('goodbye, world!')
```

`test.py`

```python
import module1
import module2

# 用“模組名.函式名”的方式（完全限定名）呼叫函式，
module1.foo()  # hello, world!
module2.foo()  # goodbye, world!
```

在匯入模組時，還可以使用`as`關鍵字對模組進行別名，這樣我們可以使用更為簡短的完全限定名。

`test.py`

```python
import module1 as m1
import module2 as m2

m1.foo()  # hello, world!
m2.foo()  # goodbye, world!
```

上面兩段程式碼，我們匯入的是定義函式的模組，我們也可以使用`from...import...`語法從模組中直接匯入需要使用的函式，程式碼如下所示。

`test.py`

```python
from module1 import foo

foo()  # hello, world!

from module2 import foo

foo()  # goodbye, world!
```

但是，如果我們如果從兩個不同的模組中匯入了同名的函式，後面匯入的函式會替換掉之前的匯入，就像下面的程式碼，呼叫`foo`會輸出`goodbye, world!`，因為我們先匯入了`module1`的`foo`，後匯入了`module2`的`foo` 。如果兩個`from...import...`反過來寫，那就是另外一番光景了。

`test.py`

```python
from module1 import foo
from module2 import foo

foo()  # goodbye, world!
```

如果想在上面的程式碼中同時使用來自兩個模組的`foo`函式還是有辦法的，大家可能已經猜到了，還是用`as`關鍵字對匯入的函式進行別名，程式碼如下所示。

`test.py`

```python
from module1 import foo as f1
from module2 import foo as f2

f1()  # hello, world!
f2()  # goodbye, world!
```

### 標準庫中的模組和函式

Python 標準庫中提供了大量的模組和函式來簡化我們的開發工作，我們之前用過的`random`模組就為我們提供了生成隨機數和進行隨機抽樣的函式；而`time`模組則提供了和時間操作相關的函式；我們之前用到過的`math`模組中還包括了計算正弦、餘弦、指數、對數等一系列的數學函式。隨著我們深入學習 Python 語言，我們還會用到更多的模組和函式。

Python 標準庫中還有一類函式是不需要`import`就能夠直接使用的，我們將其稱之為**內建函式**，這些內建函式不僅有用而且還很常用，下面的表格列出了一部分的內建函式。

| 函式    | 說明                                                         |
| ------- | ------------------------------------------------------------ |
| `abs`   | 返回一個數的絕對值，例如：`abs(-1.3)`會返回`1.3`。           |
| `bin`   | 把一個整數轉換成以`'0b'`開頭的二進位制字串，例如：`bin(123)`會返回`'0b1111011'`。 |
| `chr`   | 將Unicode編碼轉換成對應的字元，例如：`chr(8364)`會返回`'€'`。 |
| `hex`   | 將一個整數轉換成以`'0x'`開頭的十六進位制字串，例如：`hex(123)`會返回`'0x7b'`。 |
| `input` | 從輸入中讀取一行，返回讀到的字串。                         |
| `len`   | 獲取字串、列表等的長度。                                   |
| `max`   | 返回多個引數或一個可迭代物件中的最大值，例如：`max(12, 95, 37)`會返回`95`。 |
| `min`   | 返回多個引數或一個可迭代物件中的最小值，例如：`min(12, 95, 37)`會返回`12`。 |
| `oct`   | 把一個整數轉換成以`'0o'`開頭的八進位制字串，例如：`oct(123)`會返回`'0o173'`。 |
| `open`  | 開啟一個檔案並返回檔案物件。                                 |
| `ord`   | 將字元轉換成對應的Unicode編碼，例如：`ord('€')`會返回`8364`。 |
| `pow`   | 求冪運算，例如：`pow(2, 3)`會返回`8`；`pow(2, 0.5)`會返回`1.4142135623730951`。 |
| `print` | 列印輸出。                                                   |
| `range` | 構造一個範圍序列，例如：`range(100)`會產生`0`到`99`的整數序列。 |
| `round` | 按照指定的精度對數值進行四捨五入，例如：`round(1.23456, 4)`會返回`1.2346`。 |
| `sum`   | 對一個序列中的項從左到右進行求和運算，例如：`sum(range(1, 101))`會返回`5050`。 |
| `type`  | 返回物件的型別，例如：`type(10)`會返回`int`；而` type('hello')`會返回`str`。 |

###  總結

**函式是對功能相對獨立且會重複使用的程式碼的封裝**。學會使用定義和使用函式，就能夠寫出更為優質的程式碼。當然，Python 語言的標準庫中已經為我們提供了大量的模組和常用的函式，用好這些模組和函式就能夠用更少的程式碼做更多的事情；如果這些模組和函式不能滿足我們的要求，可能就需要自定義函式，然後再透過模組的概念來管理這些自定義函式。