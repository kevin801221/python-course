## 函式應用實戰

### 例子1：隨機驗證碼

設計一個生成隨機驗證碼的函式，驗證碼由數字和英文大小寫字母構成，長度可以透過引數設定。

```python
import random
import string

ALL_CHARS = string.digits + string.ascii_letters


def generate_code(*, code_len=4):
    """
    生成指定長度的驗證碼
    :param code_len: 驗證碼的長度(預設4個字元)
    :return: 由大小寫英文字母和數字構成的隨機驗證碼字串
    """
    return ''.join(random.choices(ALL_CHARS, k=code_len))
```

> **說明1**：`string`模組的`digits`代表0到9的數字構成的字串`'0123456789'`，`string`模組的`ascii_letters`代表大小寫英文字母構成的字串`'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`。
>
> **說明2**：`random`模組的`sample`和`choices`函式都可以實現隨機抽樣，`sample`實現無放回抽樣，這意味著抽樣取出的元素是不重複的；`choices`實現有放回抽樣，這意味著可能會重複選中某些元素。這兩個函式的第一個引數代表抽樣的總體，而引數`k`代表樣本容量，需要說明的是`choices`函式的引數`k`是一個命名關鍵字引數，在傳參時必須指定引數名。

可以用下面的程式碼生成5組隨機驗證碼來測試上面的函式。

```python
for _ in range(5):
    print(generate_code()) 
```

輸出：

```
59tZ
QKU5
izq8
IBBb
jIfX
```

或者

```python
for _ in range(5):
    print(generate_code(code_len=6))
```

輸出：

```
FxJucw
HS4H9G
0yyXfz
x7fohf
ReO22w
```

> **說明**：我們設計的`generate_code`函式的引數是命名關鍵字引數，由於它有預設值，可以不給它傳值，使用預設值4。如果需要給函式傳入引數，必須指定引數名`code_len`。

### 例子2：判斷素數

設計一個判斷給定的大於1的正整數是不是質數的函式。質數是隻能被1和自身整除的正整數（大於1），如果一個大於 1 的正整數 $\small{N}$ 是質數，那就意味著在 2 到 $\small{N-1}$ 之間都沒有它的因子。

```python
def is_prime(num: int) -> bool:
    """
    判斷一個正整數是不是質數
    :param num: 大於1的正整數
    :return: 如果num是質數返回True，否則返回False
    """
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True
```

> **說明1**：上面`is_prime`函式的引數`num`後面的`: int`用來標註引數的型別，雖然它對程式碼的執行結果不產生任何影響，但是很好的增強了程式碼的可讀性。同理，引數列表後面的`-> bool`用來標註函式返回值的型別，它也不會對程式碼的執行結果產生影響，但是卻讓我們清楚的知道，呼叫函式會得到一個布林值，要麼是`True`，要麼是`False`。
>
> **說明2**：上面的迴圈並不需要從 2 迴圈到 $\small{N-1}$ ，因為如果迴圈進行到 $\small{\sqrt{N}}$ 時，還沒有找到$\small{N}$的因子，那麼 $\small{\sqrt{N}}$ 之後也不會出現 $\small{N}$ 的因子，大家可以自己想一想這是為什麼。

### 例子3：最大公約數和最小公倍數

設計計算兩個正整數最大公約數和最小公倍數的函式。 $\small{x}$ 和 $\small{y}$ 的最大公約數是能夠同時整除 $\small{x}$ 和 $\small{y}$ 的最大整數，如果 $\small{x}$ 和 $\small{y}$ 互質，那麼它們的最大公約數為 1； $\small{x}$ 和 $\small{y}$ 的最小公倍數是能夠同時被 $\small{x}$ 和 $\small{y}$ 整除的最小正整數，如果 $\small{x}$ 和 $\small{y}$ 互質，那麼它們的最小公倍數為 $\small{x \times y}$ 。需要提醒大家注意的是，計算最大公約數和最小公倍數是兩個不同的功能，應該設計成兩個函式，而不是把兩個功能放到同一個函式中。

```python
def lcm(x: int, y: int) -> int:
    """求最小公倍數"""
    return x * y // gcd(x, y)


def gcd(x: int, y: int) -> int:
    """求最大公約數"""
    while y % x != 0:
        x, y = y % x, x
    return x
```

> **說明**：函式之間可以相互呼叫，上面求最小公倍數的`lcm`函式呼叫了求最大公約數的`gcd`函式，透過 $\frac{x \times y}{ gcd(x, y)}$ 來計算最小公倍數。

### 例子4：資料統計

假設樣本資料儲存一個列表中，設計計算樣本資料描述性統計資訊的函式。描述性統計資訊通常包括：算術平均值、中位數、極差（最大值和最小值的差）、方差、標準差、變異係數等，計算公式如下所示。

樣本均值（sample mean）：

$$
\bar{x} = \frac{\sum_{i=1}^{n}x_{i}}{n} = \frac{x_{1}+x_{2}+\cdots +x_{n}}{n}
$$

樣本方差（sample variance）：

$$
s^2 = \frac {\sum_{i=1}^{n}(x_i - \bar{x})^2} {n-1}
$$

樣本標準差（sample standard deviation）：

$$
s = \sqrt{\frac{\sum_{i=1}^{n}(x_i - \bar{x})^2}{n-1}}
$$

變異係數（coefficient of sample variation）：

$$
CV = \frac{s}{\bar{x}}
$$

```python
def ptp(data):
    """極差（全距）"""
    return max(data) - min(data)


def mean(data):
    """算術平均"""
    return sum(data) / len(data)


def median(data):
    """中位數"""
    temp, size = sorted(data), len(data)
    if size % 2 != 0:
        return temp[size // 2]
    else:
        return mean(temp[size // 2 - 1:size // 2 + 1])


def var(data, ddof=1):
    """方差"""
    x_bar = mean(data)
    temp = [(num - x_bar) ** 2 for num in data]
    return sum(temp) / (len(temp) - ddof)


def std(data, ddof=1):
    """標準差"""
    return var(data, ddof) ** 0.5


def cv(data, ddof=1):
    """變異係數"""
    return std(data, ddof) / mean(data)


def describe(data):
    """輸出描述性統計資訊"""
    print(f'均值: {mean(data)}')
    print(f'中位數: {median(data)}')
    print(f'極差: {ptp(data)}')
    print(f'方差: {var(data)}')
    print(f'標準差: {std(data)}')
    print(f'變異係數: {cv(data)}')
```

> **說明1**：中位數是將資料按照升序或降序排列後位於中間的數，它描述了資料的中等水平。中位數的計算分兩種情況：當資料體量$n$為奇數時，中位數是位於 $\frac{n + 1}{2}$ 位置的元素；當資料體量 $\small{n}$ 為偶數時，中位數是位於 $\frac{n}{2}$ 和 $\frac{n}{2} + 1$ 兩個位置元素的均值。
>
> **說明2**：計算方差和標準差的函式中有一個名為`ddof`的引數，它代表了可以調整的自由度，預設值為 1。在計算樣本方差和樣本標準差時，需要進行自由度校正；如果要計算總體方差和總體標準差，可以將`ddof`引數賦值為 0，即不需要進行自由度校正。
>
> **說明3**：`describe`函式將上面封裝好的統計函式組裝到一起，用於輸出資料的描述性統計資訊。事實上，Python 標準庫中有一個名為`statistics`的模組，它已經把獲取描述性統計資訊的函式封裝好了，有興趣的讀者可以自行了解。

### 例子5：雙色球隨機選號

我們用函式重構之前講過的雙色球隨機選號的例子（《第09課：常用資料結構之列表-2》），將生成隨機號碼和輸出一組號碼的功能分別封裝到兩個函式中，然後透過呼叫函式實現機選`N`注號碼的功能。

```python
"""
雙色球隨機選號程式

Author: Kevin
Version: 1.3
"""
import random

RED_BALLS = [i for i in range(1, 34)]
BLUE_BALLS = [i for i in range(1, 17)]


def choose():
    """
    生成一組隨機號碼
    :return: 儲存隨機號碼的列表
    """
    selected_balls = random.sample(RED_BALLS, 6)
    selected_balls.sort()
    selected_balls.append(random.choice(BLUE_BALLS))
    return selected_balls


def display(balls):
    """
    格式輸出一組號碼
    :param balls: 儲存隨機號碼的列表
    """
    for ball in balls[:-1]:
        print(f'\033[031m{ball:0>2d}\033[0m', end=' ')
    print(f'\033[034m{balls[-1]:0>2d}\033[0m')


n = int(input('生成幾注號碼: '))
for _ in range(n):
    display(choose())
```

> **說明**：大家看看`display(choose())`這行程式碼，這裡我們先透過`choose`函式獲得一組隨機號碼，然後把`choose`函式的返回值作為`display`函式的引數，透過`display`函式將選中的隨機號碼顯示出來。重構之後的程式碼邏輯非常清晰，程式碼的可讀性更強了。如果有人為你封裝了這兩個函式，你僅僅是函式的呼叫者，其實你根本不用關心`choose`函式和`display`函式的內部實現，你只需要知道呼叫`choose`函式可以生成一組隨機號碼，而呼叫`display`函式傳入一個列表，就可以輸出這組號碼。將來我們使用各種各樣的 Python 三方庫時，我們也根本不關注它們的底層實現，我們需要知道的僅僅是呼叫哪個函式可以解決問題。

### 總結

在寫程式碼尤其是開發商業專案的時候，一定要有意識的**將相對獨立且重複使用的功能封裝成函式**，這樣不管是自己還是團隊的其他成員都可以透過呼叫函式的方式來使用這些功能，減少工作中那些重複且乏味的勞動。