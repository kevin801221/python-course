## 迴圈進階

在上一節中，我們學習了`for-in`迴圈和`while`迴圈的基本用法。本節將介紹`break`和`continue`關鍵字、巢狀迴圈結構，以及迴圈的實際應用案例。

### break和continue

如果把`while`迴圈的條件設定為`True`，即讓條件恆成立會怎麼樣呢？我們看看下面的程式碼，還是使用`while`構造迴圈結構，計算 1 到 100 的偶數和。

```python
"""
從1到100的偶數求和

Version: 1.4
Author: Kevin
"""
total = 0
i = 2
while True:
    total += i
    i += 2
    if i > 100:
        break
print(total)
```

上面的程式碼中使用`while True`構造了一個條件恆成立的迴圈，也就意味著如果不做特殊處理，迴圈是不會結束的，這就是我們常說的"死迴圈"。為了在`i`的值超過 100 後讓迴圈停下來，我們使用了`break`關鍵字，它的作用是終止迴圈結構的執行。需要注意的是，`break`只能終止它所在的那個迴圈，這一點在使用巢狀迴圈結構時需要引起注意，後面我們會講到什麼是巢狀的迴圈結構。

除了`break`之外，還有另一個在迴圈結構中可以使用的關鍵字`continue`，它可以用來放棄本次迴圈後續的程式碼直接讓迴圈進入下一輪，程式碼如下所示。

```python
"""
從1到100的偶數求和

Version: 1.5
Author: Kevin
"""
total = 0
for i in range(1, 101):
    if i % 2 != 0:
        continue
    total += i
print(total)
```

> **說明**：上面的程式碼使用`continue`關鍵字跳過了`i`是奇數的情況，只有在`i`是偶數的前提下，才會執行到`total += i`。

### 巢狀的迴圈結構

和分支結構一樣，迴圈結構也是可以巢狀的，也就是說在迴圈結構中還可以構造迴圈結構。下面的例子演示瞭如何透過巢狀的迴圈來輸出一個乘法口訣表（九九表）。

```python
"""
列印乘法口訣表

Version: 1.0
Author: Kevin
"""
for i in range(1, 10):
    for j in range(1, i + 1):
        print(f'{i}×{j}={i * j}', end='\t')
    print()
```

上面的程式碼中，`for-in`迴圈的迴圈體中又用到了`for-in`迴圈，外面的迴圈用來控制產生`i`行的輸出，而裡面的迴圈則用來控制在一行中輸出`j`列。顯然，裡面的`for-in`迴圈的輸出就是乘法口訣表中的一整行。所以在裡面的迴圈完成時，我們用了一個`print()`來實現換行的效果，讓下面的輸出重新另起一行，最後的輸出如下所示。

```
1×1=1
2×1=2	2×2=4
3×1=3	3×2=6	3×3=9
4×1=4	4×2=8	4×3=12	4×4=16
5×1=5	5×2=10	5×3=15	5×4=20	5×5=25
6×1=6	6×2=12	6×3=18	6×4=24	6×5=30	6×6=36
7×1=7	7×2=14	7×3=21	7×4=28	7×5=35	7×6=42	7×7=49
8×1=8	8×2=16	8×3=24	8×4=32	8×5=40	8×6=48	8×7=56	8×8=64
9×1=9	9×2=18	9×3=27	9×4=36	9×5=45	9×6=54	9×7=63	9×8=72	9×9=81
```

### 迴圈結構的應用

#### 例子1：判斷素數

要求：輸入一個大於 1 的正整數，判斷它是不是素數。

> **提示**：素數指的是隻能被 1 和自身整除的大於 1 的整數。例如對於正整數 $\small{n}$，我們可以透過在 2 到 $\small{n - 1}$ 之間尋找有沒有 $\small{n}$ 的因子，來判斷它到底是不是一個素數。當然，迴圈不用從 2 開始到 $\small{n - 1}$ 結束，因為對於大於 1 的正整數，因子應該都是成對出現的，所以迴圈到 $\small{\sqrt{n}}$ 就可以結束了。

```python
"""
輸入一個大於1的正整數判斷它是不是素數

Version: 1.0
Author: Kevin
"""
num = int(input('請輸入一個正整數: '))
end = int(num ** 0.5)
is_prime = True
for i in range(2, end + 1):
    if num % i == 0:
        is_prime = False
        break
if is_prime:
    print(f'{num}是素數')
else:
    print(f'{num}不是素數')
```

> **說明**：上面的程式碼中我們用了布林型的變數`is_prime`，我們先將它賦值為`True`，假設`num`是一個素數；接下來，我們在 2 到`num ** 0.5`的範圍尋找`num`的因子，如果找到了`num`的因子，那麼它一定不是素數，此時我們將`is_prime`賦值為`False`，同時使用`break`關鍵字終止迴圈結構；最後，我們根據`is_prime`的值是`True`還是`False`來給出不同的輸出。

#### 例子2：最大公約數

要求：輸入兩個大於 0 的正整數，求兩個數的最大公約數。

> **提示**：兩個數的最大公約數是兩個數的公共因子中最大的那個數。

```python
"""
輸入兩個正整數求它們的最大公約數

Version: 1.0
Author: Kevin
"""
x = int(input('x = '))
y = int(input('y = '))
for i in range(x, 0, -1):
    if x % i == 0 and y % i == 0:
        print(f'最大公約數: {i}')
        break
```

> **說明**：上面程式碼中`for-in`迴圈的迴圈變數值是從大到小的，這樣我們找到的能夠同時整除`x`和`y`的因子`i`，就是`x`和`y`的最大公約數，此時我們用`break`終止迴圈。如果`x`和`y`互質，那麼迴圈會執行到`i`變成 1，因為 1 是所有正整數的因子，此時`x`和`y`的最大公約數就是 1。

用上面程式碼的找最大公約數在執行效率是有問題的。假如`x`的值是`999999999998`，`y`的值是`999999999999`，很顯然兩個數是互質的，最大公約數為 1。但是我們使用上面的程式碼，迴圈會重複`999999999998`次，這通常是難以接受的。我們可以使用歐幾里得演算法來找最大公約數，它能幫我們更快的得到想要的結果，程式碼如下所示。

```python
"""
輸入兩個正整數求它們的最大公約數

Version: 1.1
Author: Kevin
"""
x = int(input('x = '))
y = int(input('y = '))
while y % x != 0:
    x, y = y % x, x
print(f'最大公約數: {x}')
```

> **說明**：解決問題的方法和步驟可以稱之為演算法，對於同一個問題，我們可以設計出不同的演算法，不同的演算法在儲存空間的佔用和執行效率上都會存在差別，而這些差別就代表了演算法的優劣。大家可以對比上面的兩段待會，體會一下為什麼我們說歐幾里得演算法是更好的選擇。上面的程式碼中`x, y = y % x, x`語句表示將`y % x`的值賦給`x`，將`x` 原來的值賦給`y`。

#### 例子3：猜數字遊戲

要求：計算機出一個 1 到 100 之間的隨機數，玩家輸入自己猜的數字，計算機給出對應的提示資訊"大一點"、"小一點"或"猜對了"，如果玩家猜中了數字，計算機提示使用者一共猜了多少次，遊戲結束，否則遊戲繼續。

```python
"""
猜數字小遊戲

Version: 1.0
Author: Kevin
"""
import random

answer = random.randrange(1, 101)
counter = 0
while True:
    counter += 1
    num = int(input('請輸入: '))
    if num < answer:
        print('大一點.')
    elif num > answer:
        print('小一點.')
    else:
        print('猜對了.')
        break
print(f'你一共猜了{counter}次.')
```

> **說明**：上面的程式碼使用`import random`匯入了 Python 標準庫的`random`模組，該模組的`randrange`函式幫助我們生成了 1 到 100 範圍的隨機數（不包括 100）。變數`counter`用來記錄迴圈執行的次數，也就是使用者一共猜了幾次，每迴圈一次`counter`的值都會加 1。

### 總結

學會了 Python 中的分支結構和迴圈結構，我們就可以解決很多實際的問題了。透過這節課的學習，大家學會了以下知識：

1. 使用`break`可以**終止迴圈**
2. 使用`continue`可以**跳過本次迴圈**，直接進入下一輪
3. 迴圈結構可以**巢狀**使用
4. 選擇合適的演算法可以大大提升程式的執行效率
