## 函式高階應用

在上一個章節中，我們探索了 Python 中的高階函式，相信大家對函式的定義和應用有了更深刻的認知。本章我們繼續為大家講解函式相關的知識，一個是 Python 中的特色語法裝飾器，一個是函式的遞迴呼叫。

### 裝飾器

Python 語言中，裝飾器是“**用一個函式裝飾另外一個函式併為其提供額外的能力**”的語法現象。裝飾器本身是一個函式，它的引數是被裝飾的函式，它的返回值是一個帶有裝飾功能的函式。透過前面的描述，相信大家已經聽出來了，裝飾器是一個高階函式，它的引數和返回值都是函式。但是，裝飾器的概念對程式語言的初學者來說，還是讓人頭疼的，下面我們先透過一個簡單的例子來說明裝飾器的作用。假設有名為`downlaod`和`upload`的兩個函式，分別用於檔案的上傳和下載，如下所示。

```python
import random
import time


def download(filename):
    """下載檔案"""
    print(f'開始下載{filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename}下載完成.')

    
def upload(filename):
    """上傳檔案"""
    print(f'開始上傳{filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename}上傳完成.')

    
download('MySQL從刪庫到跑路.avi')
upload('Python從入門到住院.pdf')
```

> **說明**：上面的程式碼用休眠一段隨機時間的方式模擬了下載和上傳檔案需要花費一定的時間，並沒有真正的聯網上傳下載檔案。用 Python 語言實現聯網上傳下載檔案也非常簡單，後面我們會講到相關的知識。

現在有一個新的需求，我們希望知道呼叫`download`和`upload`函式上傳下載檔案到底用了多少時間，這應該如何實現呢？相信很多小夥伴已經想到了，我們可以在函式開始執行的時候記錄一個時間，在函式呼叫結束後記錄一個時間，兩個時間相減就可以計算出下載或上傳的時間，程式碼如下所示。

```python
start = time.time()
download('MySQL從刪庫到跑路.avi')
end = time.time()
print(f'花費時間: {end - start:.2f}秒')
start = time.time()
upload('Python從入門到住院.pdf')
end = time.time()
print(f'花費時間: {end - start:.2f}秒')
```

透過上面的程式碼，我們可以在下載和上傳檔案時記錄下耗費的時間，但不知道大家是否注意到，上面記錄時間、計算和顯示執行時間的程式碼都是重複程式碼。有程式設計經驗的人都知道，**重複的程式碼是萬惡之源**，那麼有沒有辦法在不寫重複程式碼的前提下，用一種簡單優雅的方式記錄下函式的執行時間呢？在 Python 語言中，裝飾器就是解決這類問題的最佳選擇。透過裝飾器語法，我們可以把跟原來的業務（上傳和下載）沒有關係計時功能的程式碼封裝到一個函式中，如果`upload`和`download`函式需要記錄時間，我們直接把裝飾器作用到這兩個函式上即可。既然上面提到了，裝飾器是一個高階函式，它的引數和返回值都是函式，我們將記錄時間的裝飾器姑且命名為`record_time`，那麼它的整體結構應該如下面的程式碼所示。

```python
def record_time(func):
    
    def wrapper(*args, **kwargs):
        
        result = func(*args, **kwargs)
        
        return result
    
    return wrapper
```

相信大家注意到了，`record_time`函式的引數`func`代表了一個被裝飾的函式，函式里面定義的`wrapper`函式是帶有裝飾功能的函式，它會執行被裝飾的函式`func`，它還需要返回在最後產生函式執行的返回值。不知大家是否留意到，上面的程式碼我在第4行和第6行留下了兩個空行，這意味著我們可以這些地方新增程式碼來實現額外的功能。`record_time`函式最終會返回這個帶有裝飾功能的函式`wrapper`並透過它替代原函式`func`，當原函式`func`被`record_time`函式裝飾後，我們呼叫它時其實呼叫的是`wrapper`函式，所以才獲得了額外的能力。`wrapper`函式的引數比較特殊，由於我們要用`wrapper`替代原函式`func`，但是我們又不清楚原函式`func`會接受哪些引數，所以我們就透過可變引數和關鍵字引數照單全收，然後在呼叫`func`的時候，原封不動的全部給它。這裡還要強調一下，Python 語言支援函式的巢狀定義，就像上面，我們可以在`record_time`函式中定義`wrapper`函式，這個操作在很多程式語言中並不被支援。

看懂這個結構後，我們就可以把記錄時間的功能寫到這個裝飾器中，程式碼如下所示。

```python
import time


def record_time(func):

    def wrapper(*args, **kwargs):
        # 在執行被裝飾的函式之前記錄開始時間
        start = time.time()
        # 執行被裝飾的函式並獲取返回值
        result = func(*args, **kwargs)
        # 在執行被裝飾的函式之後記錄結束時間
        end = time.time()
        # 計算和顯示被裝飾函式的執行時間
        print(f'{func.__name__}執行時間: {end - start:.2f}秒')
        # 返回被裝飾函式的返回值
        return result
    
    return wrapper
```

寫裝飾器雖然頗費周折，但是這是個一勞永逸的騷操作，將來再有記錄函式執行時間的需求時，我們只需要新增上面的裝飾器即可。使用上面的裝飾器函式有兩種方式，第一種方式就是直接呼叫裝飾器函式，傳入被裝飾的函式並獲得返回值，我們可以用這個返回值直接替代原來的函式，那麼在呼叫時就已經獲得了裝飾器提供的額外的能力（記錄執行時間），大家試試下面的程式碼就明白了。

```python
download = record_time(download)
upload = record_time(upload)
download('MySQL從刪庫到跑路.avi')
upload('Python從入門到住院.pdf')
```

在 Python 中，使用裝飾器很有更為便捷的**語法糖**（程式語言中新增的某種語法，這種語法對語言的功能沒有影響，但是使用更加方法，程式碼的可讀性也更強，我們將其稱之為“語法糖”或“糖衣語法”），可以用`@裝飾器函式`將裝飾器函式直接放在被裝飾的函式上，效果跟上面的程式碼相同。我們把完整的程式碼為大家羅列出來，大家可以再看看我們是如何定義和使用裝飾器的。

```python
import random
import time


def record_time(func):

    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__}執行時間: {end - start:.2f}秒')
        return result

    return wrapper


@record_time
def download(filename):
    print(f'開始下載{filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename}下載完成.')


@record_time
def upload(filename):
    print(f'開始上傳{filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename}上傳完成.')


download('MySQL從刪庫到跑路.avi')
upload('Python從入門到住院.pdf')
```

上面的程式碼，我們透過裝飾器語法糖為`download`和`upload`函式新增了裝飾器，被裝飾後的`download`和`upload`函式其實就是我們在裝飾器中返回的`wrapper`函式，呼叫它們其實就是在呼叫`wrapper`函式，所以才有了記錄函式執行時間的功能。

如果在程式碼的某些地方，我們想去掉裝飾器的作用執行原函式，那麼在定義裝飾器函式的時候，需要做一點點額外的工作。Python 標準庫`functools`模組的`wraps`函式也是一個裝飾器，我們將它放在`wrapper`函式上，這個裝飾器可以幫我們保留被裝飾之前的函式，這樣在需要取消裝飾器時，可以透過被裝飾函式的`__wrapped__`屬性獲得被裝飾之前的函式。

```python
import random
import time

from functools import wraps


def record_time(func):

    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__}執行時間: {end - start:.2f}秒')
        return result

    return wrapper


@record_time
def download(filename):
    print(f'開始下載{filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename}下載完成.')


@record_time
def upload(filename):
    print(f'開始上傳{filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename}上傳完成.')


# 呼叫裝飾後的函式會記錄執行時間
download('MySQL從刪庫到跑路.avi')
upload('Python從入門到住院.pdf')
# 取消裝飾器的作用不記錄執行時間
download.__wrapped__('MySQL必知必會.pdf')
upload.__wrapped__('Python從新手到大師.pdf')
```

**裝飾器函式本身也可以引數化**，簡單的說就是裝飾器也是可以透過呼叫者傳入的引數來進行定製的，這個知識點我們在後面用到的時候再為大家講解。

### 遞迴呼叫

Python 中允許函式巢狀定義，也允許函式之間相互呼叫，而且一個函式還可以直接或間接的呼叫自身。函式自己呼叫自己稱為遞迴呼叫，那麼遞迴呼叫有什麼用處呢？現實中，有很多問題的定義本身就是一個遞迴定義，例如我們之前講到的階乘，非負整數`N`的階乘是`N`乘以`N-1`的階乘，即 $\small{N! = N \times (N-1)!}$ ，定義的左邊和右邊都出現了階乘的概念，所以這是一個遞迴定義。既然如此，我們可以使用遞迴呼叫的方式來寫一個求階乘的函式，程式碼如下所示。

```python
def fac(num):
    if num in (0, 1):
        return 1
    return num * fac(num - 1)
```

上面的程式碼中，`fac`函式中又呼叫了`fac`函式，這就是所謂的遞迴呼叫。程式碼第2行的`if`條件叫做遞迴的收斂條件，簡單的說就是什麼時候要結束函式的遞迴呼叫，在計算階乘時，如果計算到`0`或`1`的階乘，就停止遞迴呼叫，直接返回`1`；程式碼第4行的`num * fac(num - 1)`是遞迴公式，也就是階乘的遞迴定義。下面，我們簡單的分析下，如果用`fac(5)`計算`5`的階乘，整個過程會是怎樣的。

```python
# 遞迴呼叫函式入棧
# 5 * fac(4)
# 5 * (4 * fac(3))
# 5 * (4 * (3 * fac(2)))
# 5 * (4 * (3 * (2 * fac(1))))
# 停止遞迴函式出棧
# 5 * (4 * (3 * (2 * 1)))
# 5 * (4 * (3 * 2))
# 5 * (4 * 6)
# 5 * 24
# 120
print(fac(5))    # 120
```

注意，函式呼叫會透過記憶體中稱為“棧”（stack）的資料結構來儲存當前程式碼的執行現場，函式呼叫結束後會透過這個棧結構恢復之前的執行現場。棧是一種先進後出的資料結構，這也就意味著最早入棧的函式最後才會返回，而最後入棧的函式會最先返回。例如呼叫一個名為`a`的函式，函式`a`的執行體中又呼叫了函式`b`，函式`b`的執行體中又呼叫了函式`c`，那麼最先入棧的函式是`a`，最先出棧的函式是`c`。每進入一個函式呼叫，棧就會增加一層棧幀（stack frame），棧幀就是我們剛才提到的儲存當前程式碼執行現場的結構；每當函式呼叫結束後，棧就會減少一層棧幀。通常，記憶體中的棧空間很小，因此遞迴呼叫的次數如果太多，會導致棧溢位（stack overflow），所以**遞迴呼叫一定要確保能夠快速收斂**。我們可以嘗試執行`fac(5000)`，看看是不是會提示`RecursionError`錯誤，錯誤訊息為：`maximum recursion depth exceeded in comparison`（超出最大遞迴深度），其實就是發生了棧溢位。

如果我們使用官方的 Python 直譯器（CPython），預設將函式呼叫的棧結構最大深度設定為`1000`層。如果超出這個深度，就會發生上面說的`RecursionError`。當然，我們可以使用`sys`模組的`setrecursionlimit`函式來改變遞迴呼叫的最大深度，但是我們不建議這樣做，因為讓遞迴快速收斂才是我們應該做的事情，否則就應該考慮使用迴圈遞推而不是遞迴。

再舉一個之前講過的生成斐波那契數列的例子，因為斐波那契數列前兩個數都是`1`，從第三個數開始，每個數是前兩個數相加的和，可以記為`f(n) = f(n - 1) + f(n - 2)`，很顯然這又是一個遞迴的定義，所以我們可以用下面的遞迴呼叫函式來計算第​`n`個斐波那契數。

```python
def fib1(n):
    if n in (1, 2):
        return 1
    return fib1(n - 1) + fib1(n - 2)


for i in range(1, 21):
    print(fib1(i))
```

需要提醒大家，上面計算斐波那契數的程式碼雖然看起來非常簡單明瞭，但執行效能是比較糟糕的。大家可以試一試，把上面程式碼`for`迴圈中`range`函式的第二個引數修改為`51`，即輸出前50個斐波那契數，看看需要多長時間，也歡迎大家在評論區留下你的程式碼執行時間。至於為什麼這麼慢，大家可以自己思考一下原因。很顯然，直接使用迴圈遞推的方式獲得斐波那契數列是更好的選擇，程式碼如下所示。

```python
def fib2(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
```

除此以外，我們還可以使用 Python 標準庫中`functools`模組的`lru_cache`函式來最佳化上面的遞迴程式碼。`lru_cache`函式是一個裝飾器函式，我們將其置於上面的函式`fib1`之上，它可以快取該函式的執行結果從而避免在遞迴呼叫的過程中產生大量的重複運算，這樣程式碼的執行效能就有“飛一般”的提升。大家可以嘗試輸出前50個斐波那契數，看看加上裝飾器以後程式碼需要執行多長時間，評論區見！

```python
from functools import lru_cache


@lru_cache()
def fib1(n):
    if n in (1, 2):
        return 1
    return fib1(n - 1) + fib1(n - 2)


for i in range(1, 51):
    print(i, fib1(i))
```

> **提示**：`lru_cache`函式是一個帶引數的裝飾器，所以上面第4行程式碼使用裝飾器語法糖時，`lru_cache`後面要跟上圓括號。`lru_cache`函式有一個非常重要的引數叫`maxsize`，它可以用來定義快取空間的大小，預設值是128。

###  總結

裝飾器是 Python 語言中的特色語法，**可以透過裝飾器來增強現有的函式**，這是一種非常有用的程式設計技巧。另一方面，透過函式遞迴呼叫，可以在程式碼層面將一些複雜的問題簡單化，但是**遞迴呼叫一定要注意收斂條件和遞迴公式**，找到遞迴公式才有機會使用遞迴呼叫，而收斂條件則確保了遞迴呼叫能停下來。函式呼叫透過記憶體中的棧空間來儲存現場和恢復現場，棧空間通常都很小，所以**遞迴如果不能迅速收斂，很可能會引發棧溢位錯誤，從而導致程式的崩潰**。
