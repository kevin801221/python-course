## 常用資料結構之列表-1

在開始本節課的內容之前，我們先給大家一個程式設計任務，將一顆色子擲 6000 次，統計每種點數出現的次數。這個任務對大家來說應該是非常簡單的，我們可以用 1 到 6 均勻分佈的隨機數來模擬擲色子，然後用 6 個變數分別記錄每個點數出現的次數，相信透過前面的學習，大家都能比較順利的寫出下面的程式碼。

```python
"""
將一顆色子擲6000次，統計每種點數出現的次數

Author: Kevin
Version: 1.0
"""
import random

f1 = 0
f2 = 0
f3 = 0
f4 = 0
f5 = 0
f6 = 0
for _ in range(6000):
    face = random.randrange(1, 7)
    if face == 1:
        f1 += 1
    elif face == 2:
        f2 += 1
    elif face == 3:
        f3 += 1
    elif face == 4:
        f4 += 1
    elif face == 5:
        f5 += 1
    else:
        f6 += 1
print(f'1點出現了{f1}次')
print(f'2點出現了{f2}次')
print(f'3點出現了{f3}次')
print(f'4點出現了{f4}次')
print(f'5點出現了{f5}次')
print(f'6點出現了{f6}次')
```

上面的程式碼非常有多麼“醜陋”相信就不用我多說了。當然，更為可怕的是，如果我們要擲兩顆或者擲更多的色子，然後統計每種點數出現的次數，那就需要定義更多的變數，寫更多的分支結構，大家想想都會感到噁心。講到這裡，相信大家心中已經有一個疑問了：有沒有辦法用一個變數來儲存多個資料，有沒有辦法用統一的程式碼對多個資料進行操作？答案是肯定的，在 Python 語言中我們可以透過容器型變數來儲存和操作多個資料，我們首先為大家介紹列表（`list`）這種新的資料型別。

### 建立列表

在 Python 中，**列表是由一系元素按特定順序構成的資料序列**，這就意味著如果我們定義一個列表型別的變數，**可以用它來儲存多個資料**。在 Python 中，可以使用`[]`字面量語法來定義列表，列表中的多個元素用逗號進行分隔，程式碼如下所示。

```python
items1 = [35, 12, 99, 68, 55, 35, 87]
items2 = ['Python', 'Java', 'Go', 'Kotlin']
items3 = [100, 12.3, 'Python', True]
print(items1)  # [35, 12, 99, 68, 55, 35, 87]
print(items2)  # ['Python', 'Java', 'Go', 'Kotlin']
print(items3)  # [100, 12.3, 'Python', True]
```

> **說明**：列表中可以有重複元素，例如`items1`中的`35`；列表中可以有不同型別的元素，例如`items3`中有`int`型別、`float`型別、`str`型別和`bool`型別的元素，但是我們通常並不建議將不同型別的元素放在同一個列表中，主要是操作起來極為不便。

我們可以使用`type`函式來檢視變數的型別，有興趣的小夥伴可以自行檢視上面的變數`items1`到底是什麼型別。因為列表可以儲存多個元素，它是一種容器型的資料型別，所以我們在給列表型別的變數起名字時，變數名通常用複數形式的單詞。

除此以外，還可以透過 Python 內建的`list`函式將其他序列變成列表。準確的說，`list`並不是一個普通的函式，它是建立列表物件的構造器，後面的課程會為大家介紹物件和構造器這些概念。

```python
items4 = list(range(1, 10))
items5 = list('hello')
print(items4)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(items5)  # ['h', 'e', 'l', 'l', 'o']
```

> **說明**：`range(1, 10)`會產生`1`到`9`的整數序列，給到`list`構造器中，會建立出由`1`到`9`的整數構成的列表。字串是字元構成的序列，上面的`list('hello')`用字串`hello`的字元作為列表元素，建立了列表物件。

### 列表的運算

我們可以使用`+`運算子實現兩個列表的拼接，拼接運算會將兩個列表中的元素連線起來放到一個列表中，程式碼如下所示。

```python
items5 = [35, 12, 99, 45, 66]
items6 = [45, 58, 29]
items7 = ['Python', 'Java', 'JavaScript']
print(items5 + items6)  # [35, 12, 99, 45, 66, 45, 58, 29]
print(items6 + items7)  # [45, 58, 29, 'Python', 'Java', 'JavaScript']
items5 += items6
print(items5)  # [35, 12, 99, 45, 66, 45, 58, 29]
```

我們可以使用`*`運算子實現列表的重複運算，`*`運算子會將列表元素重複指定的次數，我們在上面的程式碼中增加兩行，如下所示。

```python
print(items6 * 3)  # [45, 58, 29, 45, 58, 29, 45, 58, 29]
print(items7 * 2)  # ['Python', 'Java', 'JavaScript', 'Python', 'Java', 'JavaScript']
```

我們可以使用`in`或`not in`運算子判斷一個元素在不在列表中，我們在上面的程式碼程式碼中再增加兩行，如下所示。

```python
print(29 in items6)  # True
print(99 in items6)  # False
print('C++' not in items7)     # True
print('Python' not in items7)  # False
```

由於列表中有多個元素，而且元素是按照特定順序放在列表中的，所以當我們想操作列表中的某個元素時，可以使用`[]`運算子，透過在`[]`中指定元素的位置來訪問該元素，這種運算稱為索引運算。需要說明的是，`[]`的元素位置可以是`0`到`N - 1`的整數，也可以是`-1`到`-N`的整數，分別稱為正向索引和反向索引，其中`N`代表列表元素的個數。對於正向索引，`[0]`可以訪問列表中的第一個元素，`[N - 1]`可以訪問最後一個元素；對於反向索引，`[-1]`可以訪問列表中的最後一個元素，`[-N]`可以訪問第一個元素，程式碼如下所示。

```python
items8 = ['apple', 'waxberry', 'pitaya', 'peach', 'watermelon']
print(items8[0])   # apple
print(items8[2])   # pitaya
print(items8[4])   # watermelon
items8[2] = 'durian'
print(items8)      # ['apple', 'waxberry', 'durian', 'peach', 'watermelon']
print(items8[-5])  # 'apple'
print(items8[-4])  # 'waxberry'
print(items8[-1])  # watermelon
items8[-4] = 'strawberry'
print(items8)      # ['apple', 'strawberry', 'durian', 'peach', 'watermelon']
```

在使用索引運算的時候要避免出現索引越界的情況，對於上面的`items8`，如果我們訪問`items8[5]`或`items8[-6]`，就會引發`IndexError`錯誤，導致程式崩潰，對應的錯誤資訊是：*list index out of range*，翻譯成中文就是“陣列索引超出範圍”。因為對於只有五個元素的列表`items8`，有效的正向索引是`0`到`4`，有效的反向索引是`-1`到`-5`。

如果希望一次性訪問列表中的多個元素，我們可以使用切片運算。切片運算是形如`[start:end:stride]`的運算子，其中`start`代表訪問列表元素的起始位置，`end`代表訪問列表元素的終止位置（終止位置的元素無法訪問），而`stride`則代表了跨度，簡單的說就是位置的增量，比如我們訪問的第一個元素在`start`位置，那麼第二個元素就在`start + stride`位置，當然`start + stride`要小於`end`。我們給上面的程式碼增加下面的語句，來使用切片運算子訪問列表元素。

```python
print(items8[1:3:1])     # ['strawberry', 'durian']
print(items8[0:3:1])     # ['apple', 'strawberry', 'durian']
print(items8[0:5:2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2:1])   # ['strawberry', 'durian']
print(items8[-2:-6:-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

> **提醒**：大家可以看看上面程式碼中的最後一行，想一想當跨度為負數時，切片運算是如何訪問元素的。

如果`start`值等於`0`，那麼在使用切片運算子時可以將其省略；如果`end`值等於`N`，`N`代表列表元素的個數，那麼在使用切片運算子時可以將其省略；如果`stride`值等於`1`，那麼在使用切片運算子時也可以將其省略。所以，下面的程式碼跟上面的程式碼作用完全相同。

```python
print(items8[1:3])     # ['strawberry', 'durian']
print(items8[:3:1])    # ['apple', 'strawberry', 'durian']
print(items8[::2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2])   # ['strawberry', 'durian']
print(items8[-2::-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

事實上，我們還可以透過切片操作修改列表中的元素，例如我們給上面的程式碼再加上一行，大家可以看看這裡的輸出。

```python
items8[1:3] = ['x', 'o']
print(items8)  # ['apple', 'x', 'o', 'peach', 'watermelon']
```

兩個列表還可以做關係運算，我們可以比較兩個列表是否相等，也可以給兩個列表比大小，程式碼如下所示。

```python
nums1 = [1, 2, 3, 4]
nums2 = list(range(1, 5))
nums3 = [3, 2, 1]
print(nums1 == nums2)  # True
print(nums1 != nums2)  # False
print(nums1 <= nums3)  # True
print(nums2 >= nums3)  # False
```

> **說明**：上面的`nums1`和`nums2`對應元素完全相同，所以`==`運算的結果是`True`。`nums2`和`nums3`的比較，由於`nums2`的第一個元素`1`小於`nums3`的第一個元素`3`，所以`nums2 >= nums3`比較的結果是`False`。兩個列表的關係運算在實際工作並不那麼常用，如果實在不理解就跳過吧，不用糾結。

### 元素的遍歷

如果想逐個取出列表中的元素，可以使用`for-in`迴圈的，有以下兩種做法。

方法一：在迴圈結構中透過索引運算，遍歷列表元素。

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for index in range(len(languages)):
    print(languages[index])
```

輸出：

```
Python
Java
C++
Kotlin
```

> **說明**：上面的`len`函式可以獲取列表元素的個數`N`，而`range(N)`則構成了從`0`到`N-1`的範圍，剛好可以作為列表元素的索引。

方法二：直接對列表做迴圈，迴圈變數就是列表元素的代表。

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for language in languages:
    print(language)
```

輸出：

```
Python
Java
C++
Kotlin
```

### 總結

講到這裡，我們可以用列表的知識來重構上面“擲色子統計每種點數出現次數”的程式碼。

```python
"""
將一顆色子擲6000次，統計每種點數出現的次數

Author: Kevin
Version: 1.1
"""
import random

counters = [0] * 6
# 模擬擲色子記錄每種點數出現的次數
for _ in range(6000):
    face = random.randrange(1, 7)
    counters[face - 1] += 1
# 輸出每種點數出現的次數
for face in range(1, 7):
    print(f'{face}點出現了{counters[face - 1]}次')
```

上面的程式碼中，我們用`counters`列表中的六個元素分別表示 1 到 6 點出現的次數，最開始的時候六個元素的值都是 0。接下來，我們用 1 到 6 均勻分佈的隨機數模擬擲色子，如果搖出 1 點，`counters[0]`的值加 1，如果搖出 2 點，`counters[1]`的值加 1，以此類推。大家感受一下，由於使用了列表型別加上迴圈結構，我們對資料的處理是批次性的，這就使得修改後的程式碼比之前的程式碼要簡單優雅得多。
