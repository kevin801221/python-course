## 常用資料結構之集合

在學習了列表和元組之後，我們再來學習一種容器型的資料型別，它的名字叫集合（set）。說到集合這個詞大家一定不會陌生，在數學課本上就有這個概念。如果我們**把一定範圍的、確定的、可以區別的事物當作一個整體來看待**，那麼這個整體就是集合，集合中的各個事物稱為集合的**元素**。通常，集合需要滿足以下要求：

1. **無序性**：一個集合中，每個元素的地位都是相同的，元素之間是無序的。
2. **互異性**：一個集合中，任何兩個元素都是不相同的，即元素在集合中只能出現一次。
3. **確定性**：給定一個集合和一個任意元素，該元素要麼屬這個集合，要麼不屬於這個集合，二者必居其一，不允許有模稜兩可的情況出現。

Python 程式中的集合跟數學上的集合沒有什麼本質區別，需要強調的是上面所說的無序性和互異性。無序性說明集合中的元素並不像列中的元素那樣存在某種次序，可以透過索引運算就能訪問任意元素，**集合並不支援索引運算**。另外，集合的互異性決定了**集合中不能有重複元素**，這一點也是集合區別於列表的地方，我們無法將重複的元素新增到一個集合中。集合型別必然是支援`in`和`not in`成員運算的，這樣就可以確定一個元素是否屬於集合，也就是上面所說的集合的確定性。**集合的成員運算在效能上要優於列表的成員運算**，這是集合的底層儲存特性決定的，此處我們暫時不做討論，大家記住這個結論即可。

> **說明**：集合底層使用了雜湊儲存（雜湊儲存），對雜湊儲存不瞭解的讀者可以先看看“Hello 演算法”網站對[雜湊表](https://www.hello-algo.com/chapter_hashing/)的講解，感謝作者的開源精神。

### 建立集合

在 Python 中，建立集合可以使用`{}`字面量語法，`{}`中需要至少有一個元素，因為沒有元素的`{}`並不是空集合而是一個空字典，字典型別我們會在下一節課中為大家介紹。當然，也可以使用 Python 內建函式`set`來建立一個集合，準確的說`set`並不是一個函式，而是建立集合物件的構造器，這個知識點會在後面講解物件導向程式設計的地方為大家介紹。我們可以使用`set`函式建立一個空集合，也可以用它將其他序列轉換成集合，例如：`set('hello')`會得到一個包含了`4`個字元的集合（重複的字元`l`只會在集合中出現一次）。除了這兩種方式，還可以使用生成式語法來建立集合，就像我們之前用生成式語法建立列表那樣。

```python
set1 = {1, 2, 3, 3, 3, 2}
print(set1)

set2 = {'banana', 'pitaya', 'apple', 'apple', 'banana', 'grape'}
print(set2)

set3 = set('hello')
print(set3)

set4 = set([1, 2, 2, 3, 3, 3, 2, 1])
print(set4)

set5 = {num for num in range(1, 20) if num % 3 == 0 or num % 7 == 0}
print(set5)
```

需要提醒大家，集合中的元素必須是`hashable`型別，所謂`hashable`型別指的是能夠計算出雜湊碼的資料型別，通常不可變型別都是`hashable`型別，如整數（`int`）、浮點小數（`float`）、布林值（`bool`）、字串（`str`）、元組（`tuple`）等。可變型別都不是`hashable`型別，因為可變型別無法計算出確定的雜湊碼，所以它們不能放到集合中。例如：我們不能將列表作為集合中的元素；同理，由於集合本身也是可變型別，所以集合也不能作為集合中的元素。我們可以建立出巢狀列表（列表的元素也是列表），但是我們不能建立出巢狀的集合，這一點在使用集合的時候一定要引起注意。

> **溫馨提示**：如果不理解上面提到的雜湊碼、雜湊儲存這些概念，可以先放放，因為它並不影響你繼續學習和使用 Python 語言。當然，如果是計算機專業的小夥伴，不理解雜湊儲存是很難被原諒的，要趕緊去補課了。

### 元素的遍歷

我們可以透過`len`函式來獲得集合中有多少個元素，但是我們不能透過索引運算來遍歷集合中的元素，因為集合元素並沒有特定的順序。當然，要實現對集合元素的遍歷，我們仍然可以使用`for-in`迴圈，程式碼如下所示。

```python
set1 = {'Python', 'C++', 'Java', 'Kotlin', 'Swift'}
for elem in set1:
    print(elem)
```

> **提示**：大家看看上面程式碼的執行結果，透過單詞輸出的順序體會一下集合的無序性。

### 集合的運算

Python 為集合型別提供了非常豐富的運算，主要包括：成員運算、交集運算、並集運算、差集運算、比較運算（相等性、子集、超集）等。

#### 成員運算

可以透過成員運算`in`和`not in `檢查元素是否在集合中，程式碼如下所示。

```python
set1 = {11, 12, 13, 14, 15}
print(10 in set1)      # False 
print(15 in set1)      # True
set2 = {'Python', 'Java', 'C++', 'Swift'}
print('Ruby' in set2)  # False
print('Java' in set2)  # True
```

#### 二元運算

集合的二元運算主要指集合的交集、並集、差集、對稱差等運算，這些運算可以透過運算子來實現，也可以透過集合型別的方法來實現，程式碼如下所示。

<img src="res/day12/set_operations.png" style="zoom:50%;">

```python
set1 = {1, 2, 3, 4, 5, 6, 7}
set2 = {2, 4, 6, 8, 10}

# 交集
print(set1 & set2)                      # {2, 4, 6}
print(set1.intersection(set2))          # {2, 4, 6}

# 並集
print(set1 | set2)                      # {1, 2, 3, 4, 5, 6, 7, 8, 10}
print(set1.union(set2))                 # {1, 2, 3, 4, 5, 6, 7, 8, 10}

# 差集
print(set1 - set2)                      # {1, 3, 5, 7}
print(set1.difference(set2))            # {1, 3, 5, 7}

# 對稱差
print(set1 ^ set2)                      # {1, 3, 5, 7, 8, 10}
print(set1.symmetric_difference(set2))  # {1, 3, 5, 7, 8, 10}
```

透過上面的程式碼可以看出，對兩個集合求交集，`&`運算子和`intersection`方法的作用是完全相同的，使用運算子的方式顯然更直觀且程式碼也更簡短。需要說明的是，集合的二元運算還可以跟賦值運算一起構成複合賦值運算，例如：`set1 |= set2`相當於`set1 = set1 | set2`，跟`|=`作用相同的方法是`update`；`set1 &= set2`相當於`set1 = set1 & set2`，跟`&=`作用相同的方法是`intersection_update`，程式碼如下所示。

```python
set1 = {1, 3, 5, 7}
set2 = {2, 4, 6}
set1 |= set2
# set1.update(set2)
print(set1)  # {1, 2, 3, 4, 5, 6, 7}
set3 = {3, 6, 9}
set1 &= set3
# set1.intersection_update(set3)
print(set1)  # {3, 6}
set2 -= set1
# set2.difference_update(set1)
print(set2)  # {2, 4}
```

#### 比較運算

兩個集合可以用`==`和`!=`進行相等性判斷，如果兩個集合中的元素完全相同，那麼`==`比較的結果就是`True`，否則就是`False`。如果集合`A`的任意一個元素都是集合`B`的元素，那麼集合`A`稱為集合`B`的子集，即對於 $\small{\forall{a} \in {A}}$ ，均有 $\small{{a} \in {B}}$ ，則 $\small{{A} \subseteq {B}}$ ，`A`是`B`的子集，反過來也可以稱`B`是`A`的超集。如果`A`是`B`的子集且`A`不等於`B`，那麼`A`就是`B`的真子集。Python 為集合型別提供了判斷子集和超集的運算子，其實就是我們非常熟悉的`<`、`<=`、`>`、`>=`這些運算子。當然，我們也可以透過集合型別的方法`issubset`和`issuperset`來判斷集合之間的關係，程式碼如下所示。

```python
set1 = {1, 3, 5}
set2 = {1, 2, 3, 4, 5}
set3 = {5, 4, 3, 2, 1}

print(set1 < set2)   # True
print(set1 <= set2)  # True
print(set2 < set3)   # False
print(set2 <= set3)  # True
print(set2 > set1)   # True
print(set2 == set3)  # True

print(set1.issubset(set2))    # True
print(set2.issuperset(set1))  # True
```

> **說明**：上面的程式碼中，`set1 < set2`判斷`set1`是不是`set2`的真子集，`set1 <= set2`判斷`set1`是不是`set2`的子集，`set2 > set1`判斷`set2`是不是`set1`的超集。當然，我們也可以透過`set1.issubset(set2)`判斷`set1`是不是`set2`的子集；透過`set2.issuperset(set1)`判斷`set2`是不是`set1`的超集。

### 集合的方法

剛才我們說過，Python 中的集合是可變型別，我們可以透過集合的方法向集合新增元素或從集合中刪除元素。

```python
set1 = {1, 10, 100}

# 新增元素
set1.add(1000)
set1.add(10000)
print(set1)  # {1, 100, 1000, 10, 10000}

# 刪除元素
set1.discard(10)
if 100 in set1:
    set1.remove(100)
print(set1)  # {1, 1000, 10000}

# 清空元素
set1.clear()
print(set1)  # set()
```

> **說明**：刪除元素的`remove`方法在元素不存在時會引發`KeyError`錯誤，所以上面的程式碼中我們先透過成員運算判斷元素是否在集合中。集合型別還有一個`pop`方法可以從集合中隨機刪除一個元素，該方法在刪除元素的同時會返回（獲得）被刪除的元素，而`remove`和`discard`方法僅僅是刪除元素，不會返回（獲得）被刪除的元素。

集合型別還有一個名為`isdisjoint`的方法可以判斷兩個集合有沒有相同的元素，如果沒有相同元素，該方法返回`True`，否則該方法返回`False`，程式碼如下所示。

```python
set1 = {'Java', 'Python', 'C++', 'Kotlin'}
set2 = {'Kotlin', 'Swift', 'Java', 'Dart'}
set3 = {'HTML', 'CSS', 'JavaScript'}
print(set1.isdisjoint(set2))  # False
print(set1.isdisjoint(set3))  # True
```

### 不可變集合

Python 中還有一種不可變型別的集合，名字叫`frozenset`。`set`跟`frozenset`的區別就如同`list`跟`tuple`的區別，`frozenset`由於是不可變型別，能夠計算出雜湊碼，因此它可以作為`set`中的元素。除了不能新增和刪除元素，`frozenset`在其他方面跟`set`是一樣的，下面的程式碼簡單的展示了`frozenset`的用法。

```python
fset1 = frozenset({1, 3, 5, 7})
fset2 = frozenset(range(1, 6))
print(fset1)          # frozenset({1, 3, 5, 7})
print(fset2)          # frozenset({1, 2, 3, 4, 5})
print(fset1 & fset2)  # frozenset({1, 3, 5})
print(fset1 | fset2)  # frozenset({1, 2, 3, 4, 5, 7})
print(fset1 - fset2)  # frozenset({7})
print(fset1 < fset2)  # False
```

### 總結

Python 中的**集合型別是一種無序容器**，**不允許有重複運算**，由於底層使用了雜湊儲存，集合中的元素必須是`hashable`型別。集合與列表最大的區別在於**集合中的元素沒有順序**、所以**不能夠透過索引運算訪問元素**、但是集合可以執行交集、並集、差集等二元運算，也可以透過關係運算子檢查兩個集合是否存在超集、子集等關係。
