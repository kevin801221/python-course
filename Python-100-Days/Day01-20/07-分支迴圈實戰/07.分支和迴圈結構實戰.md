## 分支和迴圈結構實戰

透過前面兩節課的學習，大家對 Python 中的分支結構和迴圈結構已經有了初步的認知。**分支結構和迴圈結構是構造程式邏輯的基礎**，它們的重要性不言而喻，但是對於初學者來說這也是比較困難的部分。很多人對分支結構和迴圈結構的語法是能夠理解的，但是遇到實際問題的時候又無法下手；**看懂別人的程式碼很容易，但是要自己寫出類似的程式碼卻又很難**。如果你也有同樣的問題和困惑，千萬不要沮喪，這只是因為你的程式設計之旅才剛剛開始，**你的練習量還沒有達到讓你可以隨心所欲寫出程式碼的程度**，只要加強程式設計練習，透過量的積累來產生質的變化，這個問題遲早都會解決的。

### 例子1：100以內的素數

> **說明**：素數指的是隻能被 1 和自身整除的正整數（不包括 1），之前我們寫過判斷素數的程式碼，這裡相當於是一個升級版本。

```python
"""
輸出100以內的素數

Version: 1.0
Author: Kevin
"""
for num in range(2, 100):
    is_prime = True
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            is_prime = False
            break
    if is_prime:
        print(num)
```

### 例子2：斐波那契數列

要求：輸出斐波那契數列中的前 20 個數。

> **說明**：斐波那契數列（Fibonacci sequence），通常也被稱作黃金分割數列，是義大利數學家萊昂納多·斐波那契（Leonardoda Fibonacci）在《計算之書》中研究理想假設條件下兔子成長率問題而引入的數列，因此這個數列也常被戲稱為“兔子數列”。斐波那契數列的特點是數列的前兩個數都是 1，從第三個數開始，每個數都是它前面兩個數的和。按照這個規律，斐波那契數列的前 10 個數是：`1, 1, 2, 3, 5, 8, 13, 21, 34, 55`。斐波那契數列在現代物理、準晶體結構、化學等領域都有直接的應用。

```python
"""
輸出斐波那契數列中的前20個數

Version: 1.0
Author: Kevin
"""

a, b = 0, 1
for _ in range(20):
    a, b = b, a + b
    print(a)
```

> **說明**：上面迴圈中的`a, b = b, a + b`表示將變數`b`的值賦給`a`，把`a + b`的值賦給`b`。透過這個遞推公式，我們可以依次獲得斐波那契數列中的數。

### 例子3：尋找水仙花數

要求：找出 100 到 999 範圍內的所有水仙花數。

> **提示**：在數論中，水仙花數（narcissistic number）也被稱為超完全數字不變數、自戀數、自冪數、阿姆斯特朗數，它是一個 $\small{N}$ 位非負整數，其各位數字的 $\small{N}$ 次方和剛好等於該數本身，例如： $\small{153 = 1^{3} + 5^{3} + 3^{3}}$ ，所以 153 是一個水仙花數； $\small{1634 = 1^{4} + 6^{4} + 3^{4} + 4^{4}}$ ，所以 1634 也是一個水仙花數。對於三位數，解題的關鍵是將它拆分為個位、十位、百位，再判斷是否滿足水仙花數的要求，這一點利用 Python 中的`//`和`%`運算子其實很容易做到。

```python
"""
找出100到999範圍內的水仙花數

Version: 1.0
Author: Kevin
"""
for num in range(100, 1000):
    low = num % 10
    mid = num // 10 % 10
    high = num // 100
    if num == low ** 3 + mid ** 3 + high ** 3:
        print(num)
```

上面利用`//`和`%`拆分一個數的小技巧在寫程式碼的時候還是很常用的。我們要將一個不知道有多少位的正整數進行反轉，例如將 12389 變成 98321，也可以利用這兩個運算來實現，程式碼如下所示。

```python
"""
正整數的反轉

Version: 1.0
Author: Kevin
"""
num = int(input('num = '))
reversed_num = 0
while num > 0:
    reversed_num = reversed_num * 10 + num % 10
    num //= 10
print(reversed_num)
```

### 例子4：百錢百雞問題

> **說明**：百錢百雞是我國古代數學家張丘建在《算經》一書中提出的數學問題：雞翁一值錢五，雞母一值錢三，雞雛三值錢一。百錢買百雞，問雞翁、雞母、雞雛各幾何？翻譯成現代文是：公雞 5 元一隻，母雞 3 元一隻，小雞 1 元三隻，用 100 塊錢買一百隻雞，問公雞、母雞、小雞各有多少隻？

```python
"""
百錢百雞問題

Version: 1.0
Author: Kevin
"""
for x in range(0, 21):
    for y in range(0, 34):
        for z in range(0, 100, 3):
            if x + y + z == 100 and 5 * x + 3 * y + z // 3 == 100:
                print(f'公雞: {x}只, 母雞: {y}只, 小雞: {z}只')
```

上面使用的方法叫做**窮舉法**，也稱為**暴力搜尋法**，這種方法透過一項一項的列舉備選解決方案中所有可能的候選項，並檢查每個候選項是否符合問題的描述，最終得到問題的解。上面的程式碼中，我們使用了巢狀的迴圈結構，假設公雞有`x`只，顯然`x`的取值範圍是 0 到 20，假設母雞有`y`只，它的取值範圍是 0 到 33，假設小雞有`z`只，它的取值範圍是 0 到 99 且取值是 3 的倍數。這樣，我們設定好 100 只雞的條件`x + y + z == 100`，設定好 100 塊錢的條件`5 * x + 3 * y + z // 3 == 100`，當兩個條件同時滿足時，就是問題的正確答案，我們用`print`函式輸出它。這種方法看起來比較笨拙，但對於運算能力非常強大的計算機來說，通常都是一個可行的甚至是不錯的選擇，只要問題的解存在就能夠找到它。

事實上，上面的程式碼還有更好的寫法，既然我們已經假設公雞有`x`只，母雞有`y`只，那麼小雞的數量就應該是`100 - x - y`，這樣減少一個條件，我們就可以把上面三層巢狀的`for-in`迴圈改寫為兩層巢狀的`for-in`迴圈。迴圈次數減少了，程式碼的執行效率就有了顯著的提升，如下所示。

```python
"""
百錢百雞問題

Version: 1.1
Author: Kevin
"""
for x in range(0, 21):
    for y in range(0, 34):
        z = 100 - x - y
        if z % 3 == 0 and 5 * x + 3 * y + z // 3 == 100:
            print(f'公雞: {x}只, 母雞: {y}只, 小雞: {z}只')
```

> **說明**：上面程式碼中的`z % 3 == 0`是為了確保小雞的數量是 3 的倍數。

### 例子5：CRAPS賭博遊戲

> **說明**：CRAPS又稱花旗骰，是美國拉斯維加斯非常受歡迎的一種的桌上賭博遊戲。該遊戲使用兩粒骰子，玩家透過搖兩粒骰子獲得點數進行遊戲。簡化後的規則是：玩家第一次搖骰子如果搖出了 7 點或 11 點，玩家勝；玩家第一次如果搖出 2 點、3 點或 12 點，莊家勝；玩家如果搖出其他點數則遊戲繼續，玩家重新搖骰子，如果玩家搖出了 7 點，莊家勝；如果玩家搖出了第一次搖的點數，玩家勝；其他點數玩家繼續搖骰子，直到分出勝負。為了增加程式碼的趣味性，我們設定遊戲開始時玩家有 1000 元的賭注，每局遊戲開始之前，玩家先下注，如果玩家獲勝就可以獲得對應下注金額的獎勵，如果莊家獲勝，玩家就會輸掉自己下注的金額。遊戲結束的條件是玩家破產（輸光所有的賭注）。

```python
"""
Craps賭博遊戲

Version: 1.0
Author: Kevin
"""
import random

money = 1000
while money > 0:
    print(f'你的總資產為: {money}元')
    # 下注金額必須大於0且小於等於玩家的總資產
    while True:
        debt = int(input('請下注: '))
        if 0 < debt <= money:
            break
    # 用兩個1到6均勻分佈的隨機數相加模擬搖兩顆色子得到的點數
    first_point = random.randrange(1, 7) + random.randrange(1, 7)
    print(f'\n玩家搖出了{first_point}點')
    if first_point == 7 or first_point == 11:
        print('玩家勝!\n')
        money += debt
    elif first_point == 2 or first_point == 3 or first_point == 12:
        print('莊家勝!\n')
        money -= debt
    else:
        # 如果第一次搖色子沒有分出勝負，玩家需要重新搖色子
        while True:
            current_point = random.randrange(1, 7) + random.randrange(1, 7)
            print(f'玩家搖出了{current_point}點')
            if current_point == 7:
                print('莊家勝!\n')
                money -= debt
                break
            elif current_point == first_point:
                print('玩家勝!\n')
                money += debt
                break
print('你破產了, 遊戲結束!')
```

### 總結

分支結構和迴圈結構都非常重要，是構造程式邏輯的基礎，**一定要透過大量的練習來達到融會貫通**。我們可以用上面講的花旗骰遊戲作為一個標準，如果你能夠很順利的完成這段程式碼，那麼分支結構和迴圈結構的知識你就已經很好的掌握了。

