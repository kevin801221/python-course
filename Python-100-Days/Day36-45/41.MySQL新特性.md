## MySQL新特性

### JSON型別

很多開發者在使用關係型資料庫做資料持久化的時候，常常感到結構化的儲存缺乏靈活性，因為必須事先設計好所有的列以及對應的資料型別。在業務發展和變化的過程中，如果需要修改表結構，這絕對是比較麻煩和難受的事情。從 MySQL 5.7 版本開始，MySQL引入了對 JSON 資料型別的支援（MySQL 8.0 解決了 JSON 的日誌效能瓶頸問題），用好 JSON 型別，其實就是打破了關係型資料庫和非關係型資料庫之間的界限，為資料持久化操作帶來了更多的便捷。

JSON 型別主要分為 JSON 物件和 JSON陣列兩種，如下所示。

1. JSON 物件

```JSON
{"name": "Kevin", "tel": "13122335566", "QQ": "957658"}
```

2. JSON 陣列

```JSON
[1, 2, 3]
```

```JSON
[{"name": "Kevin", "tel": "13122335566"}, {"name": "王大錘", "QQ": "123456"}]
```

哪些地方需要用到JSON型別呢？舉一個簡單的例子，現在很多產品的使用者登入都支援多種方式，例如手機號、微信、QQ、新浪微博等，但是一般情況下我們又不會要求使用者提供所有的這些資訊，那麼用傳統的設計方式，就需要設計多個列來對應多種登入方式，可能還需要允許這些列存在空值，這顯然不是很好的選擇；另一方面，如果產品又增加了一種登入方式，那麼就必然要修改之前的表結構，這就更讓人痛苦了。但是，有了 JSON 型別，剛才的問題就迎刃而解了，我們可以做出如下所示的設計。

```SQL
CREATE TABLE `tb_test`
(
`user_id`    bigint unsigned,
`login_info` json,
PRIMARY KEY (`user_id`)
);

INSERT INTO `tb_test` 
VALUES 
    (1, '{"tel": "13122335566", "QQ": "654321", "wechat": "jackfrued"}'),
    (2, '{"tel": "13599876543", "weibo": "wangdachui123"}');
```

如果要查詢使用者的手機和微訊號，可以用如下所示的 SQL 語句。

```SQL
SELECT `user_id`
     , JSON_UNQUOTE(JSON_EXTRACT(`login_info`, '$.tel')) AS 手機號
     , JSON_UNQUOTE(JSON_EXTRACT(`login_info`, '$.wechat')) AS 微信 
FROM `tb_test`;
```

```
+---------+-------------+-----------+
| user_id | 手機號      | 微信       |
+---------+-------------+-----------+
|       1 | 13122335566 | jackfrued |
|       2 | 13599876543 | NULL      |
+---------+-------------+-----------+
```

因為支援 JSON 型別，MySQL 也提供了配套的處理 JSON 資料的函式，就像上面用到的`json_extract`和`json_unquote`。當然，上面的 SQL 還有更為便捷的寫法，如下所示。

```SQL
SELECT `user_id`
     , `login_info` ->> '$.tel' AS 手機號
     , `login_info` ->> '$.wechat' AS 微信
  FROM `tb_test`;
```

再舉個例子，如果我們的產品要實現使用者畫像功能（給使用者打標籤），然後基於使用者畫像給使用者推薦平臺的服務或消費品之類的東西，我們也可以使用 JSON 型別來儲存使用者畫像資料，示意程式碼如下所示。

建立畫像標籤表。

```SQL
CREATE TABLE `tb_tags`
(
`tag_id`   int unsigned NOT NULL COMMENT '標籤ID',
`tag_name` varchar(20)  NOT NULL COMMENT '標籤名',
PRIMARY KEY (`tag_id`)
);

INSERT INTO `tb_tags` (`tag_id`, `tag_name`) 
VALUES
    (1, '70後'),
    (2, '80後'),
    (3, '90後'),
    (4, '00後'),
    (5, '愛運動'),
    (6, '高學歷'),
    (7, '小資'),
    (8, '有房'),
    (9, '有車'),
    (10, '愛看電影'),
    (11, '愛網購'),
    (12, '常點外賣');
```

為使用者打標籤。

```SQL
CREATE TABLE `tb_users_tags`
(
`user_id`   bigint unsigned NOT NULL COMMENT '使用者ID',
`user_tags` json            NOT NULL COMMENT '使用者標籤'
);

INSERT INTO `tb_users_tags`
VALUES
    (1, '[2, 6, 8, 10]'),
    (2, '[3, 10, 12]'),
    (3, '[3, 8, 9, 11]');
```

接下來，我們透過一組查詢來了解 JSON 型別的巧妙之處。

1. 查詢愛看電影（有`10`這個標籤）的使用者ID。

    ```SQL
    SELECT `user_id`
      FROM `tb_users_tags`
     WHERE 10 MEMBER OF (`user_tags`->'$');
    ```

2. 查詢愛看電影（有`10`這個標籤）的80後（有`2`這個標籤）使用者ID。

    ```SQL
    SELECT `user_id`
      FROM `tb_users_tags`
     WHERE JSON_CONTAINS(`user_tags`->'$', '[2, 10]');
    ```

3. 查詢愛看電影或80後或90後的使用者ID。

    ```SQL
    SELECT `user_id`
      FROM `tb_users_tags`
     WHERE JSON_OVERLAPS(user_tags->'$', '[2, 3, 10]');
    ```

> **說明**：上面的查詢用到了`member of`謂詞和兩個 JSON 函式，`json_contains`可以檢查 JSON 陣列是否包含了指定的元素，而`json_overlaps`可以檢查 JSON 陣列是否與指定的陣列有重疊部分。

### 視窗函式

MySQL 從8.0開始支援視窗函式，大多數商業資料庫和一些開源資料庫早已提供了對視窗函式的支援，有的也將其稱之為 OLAP（聯機分析和處理）函式，聽名字就知道跟統計和分析相關。為了幫助大家理解視窗函式，我們先說說視窗的概念。

視窗可以理解為記錄的集合，視窗函式也就是在滿足某種條件的記錄集合上執行的特殊函式，對於每條記錄都要在此視窗內執行函式。視窗函式和我們上面講到的聚合函式比較容易混淆，二者的區別主要在於聚合函式是將多條記錄聚合為一條記錄，視窗函式是每條記錄都會執行，執行後記錄條數不會變。視窗函式不僅僅是幾個函式，它是一套完整的語法，函式只是該語法的一部分，基本語法如下所示：

```SQL
<視窗函式> OVER (PARTITION BY <用於分組的列名> ORDER BY <用於排序的列名>  ROWS BETWEEN ... AND ...)
<視窗函式> OVER (PARTITION BY <用於分組的列名> ORDER BY <用於排序的列名> RANGE BETWEEN ... AND ...)
```

上面語法中，視窗函式的位置可以放以下兩種函式：

1. 專用視窗函式，包括：`lead`、`lag`、`first_value`、`last_value`、`rank`、`dense_rank`和`row_number`等。
2. 聚合函式，包括：`sum`、`avg`、`max`、`min`和`count`等。

下面為大家舉幾個使用視窗函式的簡單例子，我們直接使用上一課建立的 hrs 資料庫。

例子1：查詢按月薪從高到低排在第4到第6名的員工的姓名和月薪。

```SQL
SELECT * 
  FROM (SELECT `ename`
             , `sal`
             , ROW_NUMBER() over (ORDER BY `sal` DESC) AS `rk`
	      FROM `tb_emp`) AS `temp`
 WHERE `rk` between 4 and 6;
```

> **說明**：上面使用的函式`row_number()`可以為每條記錄生成一個行號，在實際工作中可以根據需要將其替換為`rank()`或`dense_rank()`函式，三者的區別可以參考官方文件或閱讀[《通俗易懂的學會：SQL視窗函式》](https://zhuanlan.zhihu.com/p/92654574)進行了解。在MySQL 8以前的版本，我們可以透過下面的方式來完成類似的操作。
>
> ```SQL
> select `rank`, `ename`, `sal` from (
>        select @a:=@a+1 as `rank`, `ename`, `sal` 
>        from `tb_emp`, (select @a:=0) as t1 order by `sal` desc
> ) as `temp` where `rank` between 4 and 6;
> ```

例子2：查詢每個部門月薪最高的兩名的員工的姓名和部門名稱。

```SQL
select `ename`, `sal`, `dname` 
from (
    select 
        `ename`, `sal`, `dno`,
        rank() over (partition by `dno` order by `sal` desc) as `rank`
    from `tb_emp`
) as `temp` natural join `tb_dept` where `rank`<=2;
```

> 說明：在MySQL 8以前的版本，我們可以透過下面的方式來完成類似的操作。
>
> ```SQL
> select `ename`, `sal`, `dname` from `tb_emp` as `t1` 
natural join `tb_dept` 
where (
        select count(*) from `tb_emp` as `t2` 
        where `t1`.`dno`=`t2`.`dno` and `t2`.`sal`>`t1`.`sal` 
)<2 order by `dno` asc, `sal` desc;
> ```

