## 索引

索引是關係型資料庫中用來提升查詢效能最為重要的手段。關係型資料庫中的索引就像一本書的目錄，我們可以想象一下，如果要從一本書中找出某個知識點，但是這本書沒有目錄，這將是一件多麼可怕的事情！我們估計得一篇一篇的翻下去，才能確定這個知識點到底在什麼位置。建立索引雖然會帶來儲存空間上的開銷，就像一本書的目錄會佔用一部分篇幅一樣，但是在犧牲空間後換來的查詢時間的減少也是非常顯著的。

MySQL 資料庫中所有資料型別的列都可以被索引。對於MySQL 8.0 版本的 InnoDB 儲存引擎來說，它支援三種型別的索引，分別是 B+ 樹索引、全文索引和 R 樹索引。這裡，我們只介紹使用得最為廣泛的 B+ 樹索引。使用 B+ 樹的原因非常簡單，因為它是目前在基於磁碟進行海量資料儲存和排序上最有效率的資料結構。B+ 樹是一棵[平衡樹](https://zh.wikipedia.org/zh-cn/%E5%B9%B3%E8%A1%A1%E6%A0%91)，樹的高度通常為3或4，但是卻可以儲存從百萬級到十億級的資料，而從這些資料裡面查詢一條資料，只需要3次或4次 I/O 操作。

B+ 樹由根節點、中間節點和葉子節點構成，其中葉子節點用來儲存排序後的資料。由於記錄在索引上是排序過的，因此在一個葉子節點內查詢資料時可以使用二分查詢，這種查詢方式效率非常的高。當資料很少的時候，B+ 樹只有一個根節點，資料也就儲存在根節點上。隨著記錄越來越多，B+ 樹會發生分裂，根節點不再儲存資料，而是提供了訪問下一層節點的指標，幫助快速確定資料在哪個葉子節點上。

在建立二維表時，我們通常都會為表指定主鍵列，主鍵列上預設會建立索引，而對於 MySQL InnoDB 儲存引擎來說，因為它使用的是索引組織表這種資料儲存結構，所以主鍵上的索引就是整張表的資料，而這種索引我們也將其稱之為**聚集索引**（clustered index）。很顯然，一張表只能有一個聚集索引，否則表的資料豈不是要儲存多次。我們自己建立的索引都是二級索引（secondary index），更常見的叫法是**非聚集索引**（non-clustered index）。透過我們自定義的非聚集索引只能定位記錄的主鍵，在獲取資料時可能需要再透過主鍵上的聚集索引進行查詢，這種現象稱為“回表”，因此透過非聚集索引檢索資料通常比使用聚集索引檢索資料要慢。

接下來我們透過一個簡單的例子來說明索引的意義，比如我們要根據學生的姓名來查詢學生，這個場景在實際開發中應該經常遇到，就跟透過商品名稱查詢商品是一個道理。我們可以使用 MySQL 的`explain`關鍵字來檢視 SQL 的執行計劃（資料庫執行 SQL 語句的具體步驟）。

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 11
     filtered: 10.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

在上面的 SQL 執行計劃中，有幾項值得我們關注：

1. `select_type`：查詢的型別。
    - `SIMPLE`：簡單 SELECT，不需要使用 UNION 操作或子查詢。
    - `PRIMARY`：如果查詢包含子查詢，最外層的 SELECT 被標記為 PRIMARY。
    - `UNION`：UNION 操作中第二個或後面的 SELECT 語句。
    - `SUBQUERY`：子查詢中的第一個 SELECT。
    - `DERIVED`：派生表的 SELECT 子查詢。
2. `table`：查詢對應的表。
3. `type`：MySQL 在表中找到滿足條件的行的方式，也稱為訪問型別，包括：`ALL`（全表掃描）、`index`（索引全掃描，只遍歷索引樹）、`range`（索引範圍掃描）、`ref`（非唯一索引掃描）、`eq_ref`（唯一索引掃描）、`const` / `system`（常量級查詢）、`NULL`（不需要訪問表或索引）。在所有的訪問型別中，很顯然 ALL 是效能最差的，它代表的全表掃描是指要掃描表中的每一行才能找到匹配的行。
4. `possible_keys`：MySQL 可以選擇的索引，但是**有可能不會使用**。
5. `key`：MySQL 真正使用的索引，如果為`NULL`就表示沒有使用索引。
6. `key_len`：使用的索引的長度，在不影響查詢的情況下肯定是長度越短越好。
7. `rows`：執行查詢需要掃描的行數，這是一個**預估值**。
8. `extra`：關於查詢額外的資訊。
    - `Using filesort`：MySQL 無法利用索引完成排序操作。
    - `Using index`：只使用索引的資訊而不需要進一步查表來獲取更多的資訊。
    - `Using temporary`：MySQL 需要使用臨時表來儲存結果集，常用於分組和排序。
    - `Impossible where`：`where`子句會導致沒有符合條件的行。
    - `Distinct`：MySQL 發現第一個匹配行後，停止為當前的行組合搜尋更多的行。
    - `Using where`：查詢的列未被索引覆蓋，篩選條件並不是索引的前導列。

從上面的執行計劃可以看出，當我們透過學生名字查詢學生時實際上是進行了全表掃描，不言而喻這個查詢效能肯定是非常糟糕的，尤其是在表中的行很多的時候。如果我們需要經常透過學生姓名來查詢學生，那麼就應該在學生姓名對應的列上建立索引，透過索引來加速查詢。

```SQL
create index idx_student_name on tb_student(stuname);
```

再次檢視剛才的 SQL 對應的執行計劃。

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 62
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

可以注意到，在對學生姓名建立索引後，剛才的查詢已經不是全表掃描而是基於索引的查詢，而且掃描的行只有唯一的一行，這顯然大大的提升了查詢的效能。MySQL 中還允許建立字首索引，即對索引欄位的前N個字元建立索引，這樣的話可以減少索引佔用的空間（但節省了空間很有可能會浪費時間，**時間和空間是不可調和的矛盾**），如下所示。

```SQL
create index idx_student_name_1 on tb_student(stuname(1));
```

上面的索引相當於是根據學生姓名的第一個字來建立的索引，我們再看看 SQL 執行計劃。

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 5
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

不知道大家是否注意到，這一次掃描的行變成了2行，因為學生表中有兩個姓“林”的學生，我們只用姓名的第一個字作為索引的話，在查詢時透過索引就會找到這兩行。

如果要刪除索引，可以使用下面的SQL。

```SQL
alter table tb_student drop index idx_student_name;
```

或者

```SQL
drop index idx_student_name on tb_student;
```

在建立索引時，我們還可以使用複合索引、函式索引（MySQL 5.7 開始支援），用好複合索引實現**索引覆蓋**可以減少不必要的排序和回表操作，這樣就會讓查詢的效能成倍的提升，有興趣的讀者可以自行研究。

我們簡單的為大家總結一下索引的設計原則：

1. **最適合**索引的列是出現在**WHERE子句**和連線子句中的列。
2. 索引列的基數越大（取值多、重複值少），索引的效果就越好。
3. 使用**字首索引**可以減少索引佔用的空間，記憶體中可以快取更多的索引。
4. **索引不是越多越好**，雖然索引加速了讀操作（查詢），但是寫操作（增、刪、改）都會變得更慢，因為資料的變化會導致索引的更新，就如同書籍章節的增刪需要更新目錄一樣。
5. 使用 InnoDB 儲存引擎時，表的普通索引都會儲存主鍵的值，所以**主鍵要儘可能選擇較短的資料型別**，這樣可以有效的減少索引佔用的空間，提升索引的快取效果。

最後，還有一點需要說明，InnoDB 使用的 B-tree 索引，數值型別的列除了等值判斷時索引會生效之外，使用`>`、`<`、`>=`、`<=`、`BETWEEN...AND... `、`<>`時，索引仍然生效；對於字串型別的列，如果使用不以萬用字元開頭的模糊查詢，索引也是起作用的，但是其他的情況會導致索引失效，這就意味著很有可能會做全表查詢。
