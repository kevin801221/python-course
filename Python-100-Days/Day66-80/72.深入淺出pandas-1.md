## 深入淺出pandas-1

Pandas 是 Wes McKinney 在2008年開發的一個強大的**分析結構化資料**的工具集。Pandas 以 NumPy 為基礎（實現資料儲存和運算），提供了專門用於資料分析的型別、方法和函式，對資料分析和資料探勘提供了很好的支援；同時 pandas 還可以跟資料視覺化工具 matplotlib 很好的整合在一起，非常輕鬆愉快的實現資料視覺化呈現。

Pandas 核心的資料型別是`Series`（資料系列）、`DataFrame`（資料窗/資料框），分別用於處理一維和二維的資料，除此之外，還有一個名為`Index`的型別及其子型別，它們為`Series`和`DataFrame`提供了索引功能。日常工作中`DataFrame`使用得最為廣泛，因為二維的資料結構剛好可以對應有行有列的表格。`Series`和`DataFrame`都提供了大量的處理資料的方法，資料分析師以此為基礎，可以實現對資料的篩選、合併、拼接、清洗、預處理、聚合、透視和視覺化等各種操作。

### 建立Series物件

Pandas 庫中的`Series`物件可以用來表示一維資料結構，但是多了索引和一些額外的功能。`Series`型別的內部結構包含了兩個陣列，其中一個用來儲存資料，另一個用來儲存資料的索引。我們可以透過列表或陣列建立`Series`物件，程式碼如下所示。

程式碼：

```Python
import numpy as np
import pandas as pd

ser1 = pd.Series(data=[120, 380, 250, 360], index=['一季度', '二季度', '三季度', '四季度'])
ser1
```

> **說明**：`Series`構造器中的`data`參數列示資料，`index`參數列示資料的索引，相當於資料對應的標籤。

輸出：

```
一季度    120
二季度    380
三季度    250
四季度    360
dtype: int64
```

透過字典建立Series物件。

程式碼：

```Python
ser2 = pd.Series({'一季度': 320, '二季度': 180, '三季度': 300, '四季度': 405})
ser2
```

> **說明**：透過字典建立`Series`物件時，字典的鍵就是資料的標籤（索引），鍵對應的值就是資料。

輸出：

```
一季度    320
二季度    180
三季度    300
四季度    405
dtype: int64
```

### Series物件的運算

#### 標量運算

我們嘗試給剛才的`ser1`每個季度加上`10`，程式碼如下所示。

程式碼：

```python
ser1 += 10
ser1
```

輸出：

```
一季度    130
二季度    390
三季度    260
四季度    370
dtype: int64
```

#### 向量運算

我們嘗試把`ser1`和`ser2`對應季度的資料加起來，程式碼如下所示。

程式碼：

```python
ser1 + ser2
```

輸出：

```
一季度    450
二季度    570
三季度    560
四季度    775
dtype: int64
```

#### 索引運算

##### 普通索引

跟陣列一樣，`Series`物件也可以進行索引和切片操作，不同的是`Series`物件因為內部維護了一個儲存索引的陣列，所以除了可以使用整數索引檢索資料外，還可以透過自己設定的索引（標籤）獲取對應的資料。

使用整數索引。

程式碼：

```Python
ser1[2]
```

輸出：

```
260
```

使用自定義索引。

程式碼：

```Python
ser1['三季度']
```

輸出：

```
260
```

程式碼：

```Python
ser1['一季度'] = 380
ser1
```

輸出：

```
一季度    380
二季度    390
三季度    260
四季度    370
dtype: int64
```

##### 切片索引

`Series`物件的切片操作跟列表、陣列類似，透過給出起始和結束索引，從原來的`Series`物件中取出或修改部分資料，這裡也可以使用整數索引和自定義的索引，程式碼如下所示。

程式碼：

```Python
ser2[1:3]
```

輸出：

```
二季度    180
三季度    300
dtype: int64
```

程式碼：

```Python
ser2['二季度':'四季度']
```

輸出：

```
二季度    180
三季度    300
四季度    405
dtype: int64
```

>**提示**：在使用自定義索引進行切片時，結束索引對應的元素也是可以取到的。

程式碼：

```Python
ser2[1:3] = 400, 500
ser2
```

輸出：

```
一季度    320
二季度    400
三季度    500
四季度    405
dtype: int64
```

##### 花式索引

程式碼：

```Python
ser2[['二季度', '四季度']]
```

輸出：

```
二季度    400
四季度    405
dtype: int64
```

程式碼：

```Python
ser2[['二季度', '四季度']] = 600, 520
ser2
```

輸出：

```
一季度    320
二季度    600
三季度    500
四季度    520
dtype: int64
```

##### 布林索引

程式碼：

```Python
ser2[ser2 >= 500]
```

輸出：

```
二季度    600
三季度    500
四季度    520
dtype: int64
```

### Series物件的屬性和方法

`Series`物件的屬性和方法非常多，我們就撿著重要的跟大家講吧。先看看下面的表格，它展示了`Series`物件常用的屬性。

| 屬性                      | 說明                                    |
| ------------------------- | --------------------------------------- |
| `dtype` / `dtypes`        | 返回`Series`物件的資料型別              |
| `hasnans`                 | 判斷`Series`物件中有沒有空值            |
| `at` / `iat`              | 透過索引訪問`Series`物件中的單個值      |
| `loc` / `iloc`            | 透過索引訪問`Series`物件中的單個值或一組值 |
| `index`                   | 返回`Series`物件的索引（`Index`物件）     |
| `is_monotonic`            | 判斷`Series`物件中的資料是否單調        |
| `is_monotonic_increasing` | 判斷`Series`物件中的資料是否單調遞增    |
| `is_monotonic_decreasing` | 判斷`Series`物件中的資料是否單調遞減    |
| `is_unique`               | 判斷`Series`物件中的資料是否獨一無二    |
| `size`                    | 返回`Series`物件中元素的個數            |
| `values`                  | 以`ndarray`的方式返回`Series`物件中的值（`ndarray`物件） |

我們可以透過下面的程式碼來了解`Series`物件的屬性。

程式碼：

```python
print(ser2.dtype)                    # 資料型別
print(ser2.hasnans)                  # 有沒有空值
print(ser2.index)                    # 索引
print(ser2.values)                   # 值
print(ser2.is_monotonic_increasing)  # 是否單調遞增
print(ser2.is_unique)                # 是否每個值都獨一無二
```

輸出：

```
int64
False
Index(['一季度', '二季度', '三季度', '四季度'], dtype='object')
[320 600 500 520]
False
True
```

`Series`物件的方法很多，下面我們透過一些程式碼片段為大家介紹常用的方法。

#### 統計相關

`Series`物件支援各種獲取描述性統計資訊的方法。

程式碼：

```Python
print(ser2.count())   # 計數
print(ser2.sum())     # 求和
print(ser2.mean())    # 求平均
print(ser2.median())  # 找中位數
print(ser2.max())     # 找最大
print(ser2.min())     # 找最小
print(ser2.std())     # 求標準差
print(ser2.var())     # 求方差
```

輸出：

```
4
1940
485.0
510.0
600
320
118.18065267490557
13966.666666666666
```

`Series`物件還有一個名為`describe()`的方法，可以獲得上述所有的描述性統計資訊，如下所示。

程式碼：

```Python
ser2.describe()
```

輸出：

```
count      4.000000
mean     485.000000
std      118.180653
min      320.000000
25%      455.000000
50%      510.000000
75%      540.000000
max      600.000000
dtype: float64
```

> **提示**：因為`describe()`返回的也是一個`Series`物件，所以也可以用`ser2.describe()['mean']`來獲取平均值，用`ser2.describe()[['max', 'min']]`來獲取最大值和最小值。

如果`Series`物件有重複的值，我們可以使用`unique()`方法獲得由獨一無二的值構成的陣列；可以使用`nunique()`方法統計不重複值的數量；如果想要統計每個值重複的次數，可以使用`value_counts()`方法，這個方法會返回一個`Series`物件，它的索引就是原來的`Series`物件中的值，而每個值出現的次數就是返回的`Series`物件中的資料，在預設情況下會按照出現次數做降序排列，如下所示。

程式碼：

```Python
ser3 = pd.Series(data=['apple', 'banana', 'apple', 'pitaya', 'apple', 'pitaya', 'durian'])
ser3.value_counts()
```

輸出：

```
apple     3
pitaya    2
durian    1
banana    1
dtype: int64
```

程式碼：

```Python
ser3.nunique()
```

輸出：

```
4
```

對於`ser3`，我們還可以用`mode()`方法來找出資料的眾數，由於眾數可能不唯一，所以`mode()`方法的返回值仍然是一個`Series`物件。

程式碼：

```python
ser3.mode()
```

輸出：

```
0    apple
dtype: object
```

#### 處理資料

`Series`物件的`isna()`和`isnull()`方法可以用於空值的判斷，`notna()`和`notnull()`方法可以用於非空值的判斷，程式碼如下所示。

程式碼：

```Python
ser4 = pd.Series(data=[10, 20, np.nan, 30, np.nan])
ser4.isna()
```

> **說明**：`np.nan`是一個IEEE 754標準的浮點小數，專門用來表示“不是一個數”，在上面的程式碼中我們用它來代表空值；當然，也可以用 Python 中的`None`來表示空值，在 pandas 中`None`也會被處理為`np.nan`。

輸出：

```
0    False
1    False
2     True
3    False
4     True
dtype: bool
```

程式碼：

```Python
ser4.notna()
```

輸出：

```
0     True
1     True
2    False
3     True
4    False
dtype: bool
```

`Series`物件的`dropna()`和`fillna()`方法分別用來刪除空值和填充空值，具體的用法如下所示。

程式碼：

```Python
ser4.dropna()
```

輸出：

```
0    10.0
1    20.0
3    30.0
dtype: float64
```

程式碼：

```Python
ser4.fillna(value=40)  # 將空值填充為40
```

輸出：

```
0    10.0
1    20.0
2    40.0
3    30.0
4    40.0
dtype: float64
```

程式碼：

```Python
ser4.fillna(method='ffill')  # 用空值前面的非空值填充
```

輸出：

```
0    10.0
1    20.0
2    20.0
3    30.0
4    30.0
dtype: float64
```

需要提醒大家注意的是，`dropna()`和`fillna()`方法都有一個名為`inplace`的引數，它的預設值是`False`，表示刪除空值或填充空值不會修改原來的`Series`物件，而是返回一個新的`Series`物件。如果將`inplace`引數的值修改為`True`，那麼刪除或填充空值會就地操作，直接修改原來的`Series`物件，此時方法的返回值是`None`。後面我們會接觸到的很多方法，包括`DataFrame`物件的很多方法都會有這個引數，它們的意義跟這裡是一樣的。

`Series`物件的`mask()`和`where()`方法可以將滿足或不滿足條件的值進行替換，如下所示。

程式碼：

```Python
ser5 = pd.Series(range(5))
ser5.where(ser5 > 0)
```

輸出：

```
0    NaN
1    1.0
2    2.0
3    3.0
4    4.0
dtype: float64
```

程式碼：

```Python
ser5.where(ser5 > 1, 10)
```

輸出：

```
0    10
1    10
2     2
3     3
4     4
dtype: int64
```

程式碼：

```Python
ser5.mask(ser5 > 1, 10)
```

輸出：

```
0     0
1     1
2    10
3    10
4    10
dtype: int64
```

`Series`物件的`duplicated()`方法可以幫助我們找出重複的資料，而`drop_duplicates()`方法可以幫我們刪除重複資料。

程式碼：

```Python
ser3.duplicated()
```

輸出：

```
0    False
1    False
2     True
3    False
4     True
5     True
6    False
dtype: bool
```

程式碼：

```Python
ser3.drop_duplicates()
```

輸出：

```
0     apple
1    banana
3    pitaya
6    durian
dtype: object
```

`Series`物件的`apply()`和`map()`方法非常重要，它們可以透過字典或者指定的函式來處理資料，把資料對映或轉換成我們想要的樣子。這兩個方法在資料準備階段非常重要，我們先來試一試這個名為`map`的方法。

程式碼：

```Python
ser6 = pd.Series(['cat', 'dog', np.nan, 'rabbit'])
ser6
```

輸出：

```
0       cat
1       dog
2       NaN
3    rabbit
dtype: object
```

程式碼：

```Python
ser6.map({'cat': 'kitten', 'dog': 'puppy'})
```

> **說明**：透過字典給出的對映規則對資料進行處理。

輸出：

```
0    kitten
1     puppy
2       NaN
3       NaN
dtype: object
```

程式碼：

```Python
ser6.map('I am a {}'.format, na_action='ignore')
```

> **說明**：將指定字串的`format`方法作用到資料系列的資料上，忽略掉所有的空值。

輸出：

```
0       I am a cat
1       I am a dog
2              NaN
3    I am a rabbit
dtype: object
```

我們建立一個新的`Series`物件，

```Python
ser7 = pd.Series([20, 21, 12],  index=['London', 'New York', 'Helsinki'])
ser7
```

輸出：

```
London      20
New York    21
Helsinki    12
dtype: int64
```

程式碼：

```Python
ser7.apply(np.square)
```

> **說明**：將求平方的函式作用到資料系列的資料上，也可以將引數`np.square`替換為`lambda x: x ** 2`。

輸出：

```
London      400
New York    441
Helsinki    144
dtype: int64
```

程式碼：

```Python
ser7.apply(lambda x, value: x - value, args=(5, ))
```

> 注意：上面`apply`方法中的`lambda`函式有兩個引數，第一個引數是資料系列中的資料，而第二個引數需要我們傳入，所以我們給`apply`方法增加了`args`引數，用於給`lambda`函式的第二個引數傳值。

輸出：

```
London      15
New York    16
Helsinki     7
dtype: int64
```

#### 取頭部值和排序

`Series`物件的`sort_index()`和`sort_values()`方法可以用於對索引和資料的排序，排序方法有一個名為`ascending`的布林型別引數，該引數用於控制排序的結果是升序還是降序；而名為`kind`的引數則用來控制排序使用的演算法，預設使用了`quicksort`，也可以選擇`mergesort`或`heapsort`；如果存在空值，那麼可以用`na_position`引數空值放在最前還是最後，預設是`last`，程式碼如下所示。

程式碼：

```Python
ser8 = pd.Series(
    data=[35, 96, 12, 57, 25, 89], 
    index=['grape', 'banana', 'pitaya', 'apple', 'peach', 'orange']
)
ser8.sort_values()  # 按值從小到大排序
```

輸出：

```
pitaya    12
peach     25
grape     35
apple     57
orange    89
banana    96
dtype: int64
```

程式碼：

```Python
ser8.sort_index(ascending=False)  # 按索引從大到小排序
```

輸出：

```
pitaya    12
peach     25
orange    89
grape     35
banana    96
apple     57
dtype: int64
```

如果要從`Series`物件中找出元素中最大或最小的“Top-N”，我們不需要對所有的值進行排序的，可以使用`nlargest()`和`nsmallest()`方法來完成，如下所示。

程式碼：

```Python
ser8.nlargest(3)  # 值最大的3個
```

輸出：

```
banana    96
orange    89
apple     57
dtype: int64
```

程式碼：

```Python
ser8.nsmallest(2)  # 值最小的2個
```

輸出：

```
pitaya    12
peach     25
dtype: int64
```

#### 繪製圖表

`Series`物件有一個名為`plot`的方法可以用來生成圖表，如果選擇生成折線圖、餅圖、柱狀圖等，預設會使用`Series`物件的索引作為橫座標，使用`Series`物件的資料作為縱座標。下面我們建立一個`Series`物件並基於它繪製柱狀圖，程式碼如下所示。

程式碼：

```Python
import matplotlib.pyplot as plt

ser9 = pd.Series({'Q1': 400, 'Q2': 520, 'Q3': 180, 'Q4': 380})
# 透過plot方法的kind指定圖表型別為柱狀圖
ser9.plot(kind='bar')
# 定製縱軸的取值範圍
plt.ylim(0, 600)
# 定製橫軸刻度（旋轉到0度）
plt.xticks(rotation=0)
# 為柱子增加資料標籤
for i in range(ser9.size):
    plt.text(i, ser9[i] + 5, ser9[i], ha='center')
plt.show()
```

輸出：

<img src="res/ser_bar_graph.png" style="zoom:35%;">

我們也可以將其繪製為餅圖，程式碼如下所示。

程式碼：

```Python
# plot方法的kind引數指定了圖表型別為餅圖
# autopct會自動計算並顯示百分比
# pctdistance用來控制百分比到圓心的距離
ser9.plot(kind='pie', autopct='%.1f%%', pctdistance=0.65)
plt.show()
```

輸出：

<img src="res/ser_pie_graph.png" style="zoom:35%;">