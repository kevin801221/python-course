## 深入淺出pandas-5

我們再來補充一些使用`DataFrame`做資料分析時會使用到的操作，這些操作不僅常見而且也非常重要。

### 計算同比環比

我們之前講過一個統計月度銷售額的例子，我們可以透過`groupby`方法做分組聚合，也可以透過`pivot_table`生成透視表，如下所示。

```python
sales_df = pd.read_excel('data/2020年銷售資料.xlsx')
sales_df['月份'] = sales_df.銷售日期.dt.month
sales_df['銷售額'] = sales_df.售價 * sales_df.銷售數量
result_df = sales_df.pivot_table(index='月份', values='銷售額', aggfunc='sum')
result_df.rename(columns={'銷售額': '本月銷售額'}, inplace=True)
result_df
```

輸出：

```
      本月銷售額
月份         
1       5409855
2       4608455
3       4164972
4       3996770
5       3239005
6       2817936
7       3501304
8       2948189
9       2632960
10      2375385
11      2385283
12      1691973
```

在得到月度銷售額之後，如果我們需要計算月環比，這裡有兩種方案。第一種方案是我們可以使用`shift`方法對資料進行移動，將上一個月的資料與本月資料對齊，然後透過`(本月銷售額 - 上月銷售額) / 上月銷售額`來計算月環比，程式碼如下所示。

```python
result_df['上月銷售額'] = result_df.本月銷售額.shift(1)
result_df
```

輸出：

```
      本月銷售額      上月銷售額
月份                    
1       5409855            NaN
2       4608455      5409855.0
3       4164972      4608455.0
4       3996770      4164972.0
5       3239005      3996770.0
6       2817936      3239005.0
7       3501304      2817936.0
8       2948189      3501304.0
9       2632960      2948189.0
10      2375385      2632960.0
11      2385283      2375385.0
12      1691973      2385283.0
```

在上面的例子中，`shift`方法的引數為`1`表示將資料向下移動一個單元，當然我們可以使用引數`-1`將資料向上移動一個單元。相信大家能夠想到，如果我們有更多年份的資料，我們可以將引數設定為`12`，這樣就可以計算今年的每個月與去年的每個月之間的同比。

```python
result_df['環比'] = (result_df.本月銷售額 - result_df.上月銷售額) / result_df.上月銷售額
result_df.style.format(
    formatter={'上月銷售額': '{:.0f}', '環比': '{:.2%}'},
    na_rep='--------'
)
```

輸出：

```
      本月銷售額      上月銷售額         環比
月份                    
1       5409855       --------     -------- 
2       4608455        5409855      -14.81%     
3       4164972        4608455       -9.62%
4       3996770        4164972       -4.04%
5       3239005        3996770      -18.96%
6       2817936        3239005      -13.00%
7       3501304        2817936       24.25%
8       2948189        3501304      -15.80%
9       2632960        2948189      -10.69%
10      2375385        2632960       -9.78%
11      2385283        2375385        0.42%
12      1691973        2385283      -29.07%
```

> **說明**：使用 JupyterLab 時，可以透過`DataFrame`物件的`style`屬性在網頁中對其進行渲染，上面的程式碼透過`Styler`物件的`format`方法將環比格式化為百分比進行顯示，此外還指定了將空值替換為`--------`。

更為簡單的第二種方案是直接使用`pct_change`方法計算變化的百分比，我們先將之前的上月銷售額和環比列刪除掉。

```python
result_df.drop(columns=['上月銷售額', '環比'], inplace=True)
```

接下來，我們使用`DataFrame`物件的`pct_change`方法完成環比的計算。值得一提的是，`pct_change`方法有一個名為`periods`的引數，它的預設值是`1`，計算相鄰兩項資料變化的百分比，這不就是我們想要的環比嗎？如果我們有很多年的資料，在計算時把這個引數的值修改為`12`，就可以得到相鄰兩年的月同比。

```python
result_df['環比'] = result_df.pct_change()
result_df
```

### 視窗計算

`DataFrame`物件的`rolling`方法允許我們將資料置於視窗中，然後用函式對視窗中的資料進行運算和處理。例如，我們獲取了某隻股票近期的資料，想製作5日均線和10日均線，那麼就需要先設定視窗再進行運算。我們先用如下所示的程式碼讀取2022年百度的股票資料，資料檔案可以透過下面的連結來獲取。

```Python
baidu_df = pd.read_excel('data/2022年股票資料.xlsx', sheet_name='BIDU')
baidu_df.sort_index(inplace=True)
baidu_df
```

輸出：

<img src="res/baidu_stock.png" style="zoom:50%;">

上面的`DataFrame`有`Open`、`High`、`Low`、`Close`、`Volume`五個列，分別代表股票的開盤價、最高價、最低價、收盤價和成交量，接下來我們對百度的股票資料進行視窗計算。

```Python
baidu_df.rolling(5).mean()
```

輸出：

<img src="res/baidu_stock_ma5.png" style="zoom:50%;">

我們也可以在`Series`上使用`rolling`設定視窗並在視窗內完成運算，例如我們可以對上面的百度股票收盤價（`Close`列）計算5日均線和10日均線，並使用`merge`函式將其組裝到一個`DataFrame`物件中並繪製出雙均線圖，程式碼如下所示。

```Python
close_ma5 = baidu_df.Close.rolling(5).mean()
close_ma10 = baidu_df.Close.rolling(10).mean()
result_df = pd.merge(close_ma5, close_ma10, left_index=True, right_index=True)
result_df.rename(columns={'Close_x': 'MA5', 'Close_y': 'MA10'}, inplace=True)
result_df.plot(kind='line', figsize=(10, 6))
plt.show()
```

輸出：

<img src="res/baidu_double_MA.png" style="zoom:50%;">

### 相關性判定

在統計學中，我們通常使用協方差（covariance）來衡量兩個隨機變數的聯合變化程度。如果變數 $\small{X}$ 的較大值主要與另一個變數 $\small{Y}$ 的較大值相對應，而兩者較小值也相對應，那麼兩個變數傾向於表現出相似的行為，協方差為正。如果一個變數的較大值主要對應於另一個變數的較小值，則兩個變數傾向於表現出相反的行為，協方差為負。簡單的說，協方差的正負號顯示著兩個變數的相關性。方差是協方差的一種特殊情況，即變數與自身的協方差。

$$
cov(X,Y) = E((X - \mu)(Y - \upsilon)) = E(X \cdot Y) - \mu\upsilon
$$

如果 $\small{X}$ 和 $\small{Y}$ 是統計獨立的，那麼二者的協方差為 0，這是因為在 $\small{X}$ 和 $\small{Y}$ 獨立的情況下：

$$
E(X \cdot Y) = E(X) \cdot E(Y) = \mu\upsilon
$$

協方差的數值大小取決於變數的大小，通常是不容易解釋的，但是正態形式的協方差可以顯示兩變數線性關係的強弱。在統計學中，皮爾遜積矩相關係數就是正態形式的協方差，它用於度量兩個變數 $\small{X}$ 和 $\small{Y}$ 之間的相關程度（線性相關），其值介於 -1 到 1 之間。

$$
\frac {cov(X, Y)} {\sigma_{X}\sigma_{Y}}
$$

估算樣本的協方差和標準差，可以得到樣本皮爾遜係數，通常用希臘字母 $\small{\rho}$ 表示。

$$
\rho = \frac {\sum_{i=1}^{n}(X_i - \bar{X})(Y_i - \bar{Y})} {\sqrt{\sum_{i=1}^{n}(X_i - \bar{X})^2} \sqrt{\sum_{i=1}^{n}(Y_i - \bar{Y})^2}}
$$

我們用 $\small{\rho}$ 值判斷指標的相關性時遵循以下兩個步驟。

1. 判斷指標間是正相關、負相關，還是不相關。
    - 當 $\small{\rho \gt 0}$，認為變數之間是正相關，也就是兩者的趨勢一致。
    - 當 $\small{\rho \lt 0}$，認為變數之間是負相關，也就是兩者的趨勢相反。
    - 當 $\small{\rho \approx 0}$，認為變數之間是不相關的，但並不代表兩個指標是統計獨立的。
2. 判斷指標間的相關程度。
    - 當 $\small{\rho}$ 的絕對值在 $\small{[0.6,1]}$ 之間，認為變數之間是強相關的。
    - 當 $\small{\rho}$ 的絕對值在 $\small{[0.1,0.6)}$ 之間，認為變數之間是弱相關的。
    - 當 $\small{\rho}$ 的絕對值在 $\small{[0,0.1)}$ 之間，認為變數之間沒有相關性。

皮爾遜相關係數適用於：

1. 兩個變數之間是線性關係，都是連續資料。
2. 兩個變數的總體是正態分佈，或接近正態的單峰分佈。
3. 兩個變數的觀測值是成對的，每對觀測值之間相互獨立。

這裡，我們順便說一下，如果兩組變數並不是來自於正態總體的連續值，我們該如何判斷相關性呢？對於定序尺度（等級），我們可以使用斯皮爾曼秩相關係數，其計算公式如下所示：

$$
r_{s}=1-{\frac {6\sum d_{i}^{2}}{n(n^{2}-1)}}
$$

其中， $\small{d_{i}=\operatorname {R} (X_{i})-\operatorname {R} (Y_{i})}$ ，即每組觀測中兩個變數的等級差值， $\small{n}$ 為觀測樣本數。

對於定類尺度（類別），我們可以使用卡方檢驗的方式來判定其是否相關。其實很多時候，連續值也可以透過分箱的方式處理成離散的等級或類別，然後使用斯皮爾曼秩相關係數或卡方檢驗的方式來判定相關性。

`DataFrame`物件的`cov`方法和`corr`方法分別用於計算協方差和相關係數，`corr`方法有一個名為`method`的引數，其預設值是`pearson`，表示計算皮爾遜相關係數；除此之外，還可以指定`kendall`或`spearman`來計算肯德爾係數或斯皮爾曼秩相關係數。

我們從名為`boston_house_price.csv`的檔案中獲取著名的波士頓房價資料集來建立一個`DataFrame`。

```python
boston_df = pd.read_csv('data/boston_house_price.csv')
boston_df
```

輸出：

<img src="res/boston_house_price.png" style="zoom:50%;">

> **說明**：上面程式碼中使用了相對路徑來訪問 CSV 檔案，也就是說 CSV 檔案在當前工作路徑下名為`data`的資料夾中。如果需要上面例子中的 CSV 檔案，可以透過下面的百度雲盤地址進行獲取。連結：<https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g?pwd=e7b4>，提取碼：e7b4。

可以看出，該資料集中包含了諸多影響房價的特徵，包括犯罪率、一氧化氮濃度、平均房間數、低收入人群佔比等，其中`PRICE`代表房價，具體情況如下所示。

<img src="res/boston_house_price_features.png" style="zoom:50%;">

接下來，我們將其中可以視為來自於正態總體的連續值，透過`corr`方法計算皮爾遜相關係數，看看哪些跟房價是正相關或負相關的關係，程式碼如下所示。

```Python
boston_df[['NOX', 'RM', 'PTRATIO', 'LSTAT', 'PRICE']].corr()
```

輸出：

<img src="res/boston_person_correlation.png" style="zoom:50%;">

可以看出，平均房間數（`RM`）跟房價有較強的正相關性，而低收入人群佔比（`LSTAT`）跟房價之間存在明顯的負相關性。

斯皮爾曼秩相關係數對資料條件的要求沒有皮爾遜相關係數嚴格，只要兩個變數的觀測值是成對的等級資料，或者是由連續變數轉化成等級的資料，不論兩個變數的總體分佈形態、樣本容量的大小如何，都可以用斯皮爾曼等級相關係數來進行研究。我們可以透過下面的方式對部分特徵進行預處理，然後計算斯皮爾曼秩相關係數。

```Python
boston_df['CRIM'] = boston_df.CRIM.apply(lambda x: x // 5 if x < 25 else 5).map(int)
boston_df['ZN'] = pd.qcut(boston_df.ZN, q=[0, 0.75, 0.8, 0.85, 0.9, 0.95, 1], labels=np.arange(6))
boston_df['AGE'] = (boston_df.AGE // 20).map(int)
boston_df['DIS'] = (boston_df.DIS // 2.05).map(int)
boston_df['B'] = (boston_df.B // 66).map(int)
boston_df['PRICE'] = pd.qcut(boston_df.PRICE, q=[0, 0.15, 0.3, 0.5, 0.7, 0.85, 1], labels=np.arange(6))
boston_df[['CRIM', 'ZN', 'AGE', 'DIS', 'B', 'PRICE']].corr(method='spearman')
```

輸出：

<img src="res/boston_spearman_correlation.png" style="zoom:50%;">

可以看出，房價跟犯罪率（`CRIM`）和房齡（`AGE`）之間存在較為明顯的負相關關係，跟住房用地尺寸（`ZN`）存在微弱的正相關關係。相關性可以幫助我們在實際工作中找到業務抓手，即找到那些能夠影響或改變工作結果的相關因素。

