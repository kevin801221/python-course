## NumPy的應用-1

Numpy 是一個開源的 Python 科學計算庫，**用於快速處理任意維度的陣列**。Numpy **支援常見的陣列和矩陣操作**，對於同樣的數值計算任務，使用 NumPy 不僅程式碼要簡潔的多，而且 NumPy 在效能上也遠遠優於原生 Python，至少是一到兩個數量級的差距，而且資料量越大，NumPy 的優勢就越明顯。

NumPy 最為核心的資料型別是`ndarray`，使用`ndarray`可以處理一維、二維和多維陣列，該物件相當於是一個快速而靈活的大資料容器。NumPy 底層程式碼使用 C 語言編寫，解決了 GIL 的限制，`ndarray`在存取資料的時候，資料與資料的地址都是連續的，這確保了可以進行高效率的批次操作，效能上遠遠優於 Python 中的`list`；另一方面`ndarray`物件提供了更多的方法來處理資料，尤其獲取資料統計特徵的方法，這些方法也是 Python 原生的`list`沒有的。

 ### 準備工作

1. 啟動 JupyterLab

    ```Bash
    jupyter lab
    ```

    > **提示**：在啟動 JupyterLab 之前，建議先安裝好資料分析相關依賴項，包括之前提到的三大神器以及相關依賴項。如果使用 Anaconda，則無需單獨安裝，可以透過 Anaconda 的 Navigator 來啟動。

2. 匯入

    ```Python
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    ```

    > **說明**：如果已經啟動了 JupyterLab 但尚未安裝相關依賴庫，例如尚未安裝`numpy`，可以在單元格中輸入`%pip install numpy`並執行該單元格來安裝 NumPy。當然，我們也可以在單元格中輸入`%pip install numpy pandas matplotlib`把 Python 資料分析三個核心的三方庫都安裝上。注意上面的程式碼，我們不僅匯入了 NumPy，還將 pandas 和 matplotlib 庫一併匯入了。

### 建立陣列物件

建立`ndarray`物件有很多種方法，下面我們介紹一些常用的方法。

方法一：使用`array`函式，透過`list`建立陣列物件

程式碼：

```Python
array1 = np.array([1, 2, 3, 4, 5])
array1
```

輸出：

```
array([1, 2, 3, 4, 5])
```

程式碼：

```Python
array2 = np.array([[1, 2, 3], [4, 5, 6]])
array2
```

輸出：

```
array([[1, 2, 3],
       [4, 5, 6]])
```

方法二：使用`arange`函式，指定取值範圍和跨度建立陣列物件

程式碼：

```Python
array3 = np.arange(0, 20, 2)
array3
```

輸出：

```
array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])
```

方法三：使用`linspace`函式，用指定範圍和元素個數建立陣列物件，生成等差數列

程式碼：

```Python
array4 = np.linspace(-1, 1, 11)
array4
```

輸出：

```
array([-1. , -0.8, -0.6, -0.4, -0.2,  0. ,  0.2,  0.4,  0.6,  0.8,  1. ])
```

方法四：使用`logspace`函式，生成等比數列

程式碼：

```python
array5 = np.logspace(1, 10, num=10, base=2)
array5
```

> **注意**：等比數列的起始值是 $\small{2^1}$ ，等比數列的終止值是 $\small{2^{10}}$ ，`num`是元素的個數，`base`就是底數。

輸出：

```
array([   2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.,  512., 1024.])
```

方法五：透過`fromstring`函式從字串提取資料建立陣列物件

程式碼：

```Python
array6 = np.fromstring('1, 2, 3, 4, 5', sep=',', dtype='i8')
array6 
```

輸出：

```
array([1, 2, 3, 4, 5])
```

方法六：透過`fromiter`函式從生成器（迭代器）中獲取資料建立陣列物件

程式碼：

```Python
def fib(how_many):
    a, b = 0, 1
    for _ in range(how_many):
        a, b = b, a + b
        yield a


gen = fib(20)
array7 = np.fromiter(gen, dtype='i8')
array7
```

輸出：

```
array([   1,    1,    2,    3,    5,    8,   13,   21,   34,   55,   89,
        144,  233,  377,  610,  987, 1597, 2584, 4181, 6765])
```

方法七：使用`numpy.random`模組的函式生成隨機數建立陣列物件

產生 10 個 $\small{[0, 1)}$ 範圍的隨機小數，程式碼：

```Python
array8 = np.random.rand(10)
array8
```

輸出：

```
array([0.45556132, 0.67871326, 0.4552213 , 0.96671509, 0.44086463,
       0.72650875, 0.79877188, 0.12153022, 0.24762739, 0.6669852 ])
```

產生 10 個 $\small{[1, 100)}$ 範圍的隨機整數，程式碼：

```Python
array9 = np.random.randint(1, 100, 10)
array9
```

輸出：

```
array([29, 97, 87, 47, 39, 19, 71, 32, 79, 34])
```

產生 20 個 $\small{\mu=50}$ ， $\small{\sigma=10}$ 的正態分佈隨機數，程式碼：

```Python
array10 = np.random.normal(50, 10, 20)
array10
```

輸出：

```
array([55.04155586, 46.43510797, 20.28371158, 62.67884053, 61.23185964,
       38.22682148, 53.17126151, 43.54741592, 36.11268017, 40.94086676,
       63.27911699, 46.92688903, 37.1593374 , 67.06525656, 67.47269463,
       23.37925889, 31.45312239, 48.34532466, 55.09180924, 47.95702787])
```

產生 $\small{[0, 1)}$ 範圍的隨機小數構成的 3 行 4 列的二維陣列，程式碼：

```Python
array11 = np.random.rand(3, 4)
array11
```

輸出：

```
array([[0.54017809, 0.46797771, 0.78291445, 0.79501326],
       [0.93973783, 0.21434806, 0.03592874, 0.88838892],
       [0.84130479, 0.3566601 , 0.99935473, 0.26353598]])
```

產生 $\small{[1, 100)}$ 範圍的隨機整數構成的三維陣列，程式碼：

```Python
array12 = np.random.randint(1, 100, (3, 4, 5))
array12
```

輸出：

```
array([[[94, 26, 49, 24, 43],
        [27, 27, 33, 98, 33],
        [13, 73,  6,  1, 77],
        [54, 32, 51, 86, 59]],

       [[62, 75, 62, 29, 87],
        [90, 26,  6, 79, 41],
        [31, 15, 32, 56, 64],
        [37, 84, 61, 71, 71]],

       [[45, 24, 78, 77, 41],
        [75, 37,  4, 74, 93],
        [ 1, 36, 36, 60, 43],
        [23, 84, 44, 89, 79]]])
```

方法八：建立全0、全1或指定元素的陣列

使用`zeros`函式，程式碼：

```Python
array13 = np.zeros((3, 4))
array13
```

輸出：

```
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])
```

使用`ones`函式，程式碼：

```Python
array14 = np.ones((3, 4))
array14
```

輸出：

```
array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])
```

使用`full`函式，程式碼：

```Python
array15 = np.full((3, 4), 10)
array15
```

輸出：

```
array([[10, 10, 10, 10],
       [10, 10, 10, 10],
       [10, 10, 10, 10]])
```

方法九：使用`eye`函式建立單位矩陣

程式碼：

```Python
np.eye(4)
```

輸出：

```
array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])
```

方法十：讀取圖片獲得對應的三維陣列

程式碼：

```Python
array16 = plt.imread('guido.jpg')
array16
```

輸出：

```
array([[[ 36,  33,  28],
        [ 36,  33,  28],
        [ 36,  33,  28],
        ...,
        [ 32,  31,  29],
        [ 32,  31,  27],
        [ 31,  32,  26]],

       [[ 37,  34,  29],
        [ 38,  35,  30],
        [ 38,  35,  30],
        ...,
        [ 31,  30,  28],
        [ 31,  30,  26],
        [ 30,  31,  25]],

       [[ 38,  35,  30],
        [ 38,  35,  30],
        [ 38,  35,  30],
        ...,
        [ 30,  29,  27],
        [ 30,  29,  25],
        [ 29,  30,  25]],

       ...,

       [[239, 178, 123],
        [237, 176, 121],
        [235, 174, 119],
        ...,
        [ 78,  68,  56],
        [ 75,  67,  54],
        [ 73,  65,  52]],

       [[238, 177, 120],
        [236, 175, 118],
        [234, 173, 116],
        ...,
        [ 82,  70,  58],
        [ 78,  68,  56],
        [ 75,  66,  51]],

       [[238, 176, 119],
        [236, 175, 118],
        [234, 173, 116],
        ...,
        [ 84,  70,  61],
        [ 81,  69,  57],
        [ 79,  67,  53]]], dtype=uint8)
```

> **說明**：上面的程式碼讀取了當前路徑下名為`guido.jpg` 的圖片檔案，計算機系統中的圖片通常由若干行若干列的畫素點構成，而每個畫素點又是由紅綠藍三原色構成的，剛好可以用三維陣列來表示。讀取圖片用到了`matplotlib`庫的`imread`函式。

### 陣列物件的屬性

`size`屬性：獲取陣列元素個數。

程式碼：

```Python
array17 = np.arange(1, 100, 2)
array18 = np.random.rand(3, 4)
print(array16.size)
print(array17.size)
print(array18.size)
```

輸出：

```
1125000
50
12
```

`shape`屬性：獲取陣列的形狀。

程式碼：

```Python
print(array16.shape)
print(array17.shape)
print(array18.shape)
```

輸出：

```
(750, 500, 3)
(50,)
(3, 4)
```

`dtype`屬性：獲取陣列元素的資料型別。

程式碼：

```Python
print(array16.dtype)
print(array17.dtype)
print(array18.dtype)
```

輸出：

```
uint8
int64
float64
```

`ndarray`物件元素的資料型別可以參考如下所示的表格。

<img src="res/dtype.jpg" style="zoom:50%;">

`ndim`屬性：獲取陣列的維度。

程式碼：

```Python
print(array16.ndim)
print(array17.ndim)
print(array18.ndim)
```

輸出：

```
3
1
2
```

`itemsize`屬性：獲取陣列單個元素佔用記憶體空間的位元組數。

程式碼：

```Python
print(array16.itemsize)
print(array17.itemsize)
print(array18.itemsize)
```

輸出：

```
1
8
8
```

`nbytes`屬性：獲取陣列所有元素佔用記憶體空間的位元組數。

程式碼：

```Python
print(array16.nbytes)
print(array17.nbytes)
print(array18.nbytes)
```

輸出：

```
1125000
400
96
```

### 陣列的索引運算

和 Python 中的列表類似，NumPy 的`ndarray`物件可以進行索引和切片操作，透過索引可以獲取或修改陣列中的元素，透過切片操作可以取出陣列的一部分，我們把切片操作也稱為切片索引。

#### 普通索引

類似於 Python 中`list`型別的索引運算。

程式碼：

```Python
array19 = np.arange(1, 10)
print(array19[0], array19[array19.size - 1])
print(array19[-array20.size], array19[-1])
```

輸出：

```
1 9
1 9
```

程式碼：

```Python
array20 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
array20[2]
```

輸出：

```
array([7, 8, 9])
```

程式碼：

```Python
print(array20[0][0])
print(array20[-1][-1])
```

輸出：

```
1
9
```

程式碼：

```Python
print(array20[1][1])
print(array20[1, 1])
```

輸出：

```
5
5
```

程式碼：

```Python
array20[1][1] = 10
array20
```

輸出：

```
array([[ 1,  2,  3],
       [ 4, 10,  6],
       [ 7,  8,  9]])
```

程式碼：

```Python
array20[1] = [10, 11, 12]
array20
```

輸出：

```
array([[ 1,  2,  3],
       [10, 11, 12],
       [ 7,  8,  9]])
```

#### 切片索引

切片索引是形如`[開始索引:結束索引:跨度]`的語法，透過指定**開始索引**（預設值無窮小）、**結束索引**（預設值無窮大）和**跨度**（預設值1），從陣列中取出指定部分的元素並構成新的陣列。因為開始索引、結束索引和步長都有預設值，所以它們都可以省略，如果不指定步長，第二個冒號也可以省略。一維陣列的切片運算跟 Python 中的`list`型別的切片非常類似，此處不再贅述，二維陣列的切片可以參考下面的程式碼，相信非常容易理解。

程式碼：

```Python
array20[:2, 1:]
```

輸出：

```
array([[ 2,  3],
       [11, 12]])
```

程式碼：

```Python
array20[2, :]
```

輸出：

```
array([7, 8, 9])
```

程式碼：

```Python
array20[2:, :]
```

輸出：

```
array([[7, 8, 9]])
```

程式碼：

```Python
array20[:, :2]
```

輸出：

```
array([[ 1,  2],
       [10, 11],
       [ 7,  8]])
```

程式碼：

```Python
array20[::2, ::2]
```

輸出：

```
array([[1, 3],
       [7, 9]])
```

程式碼：

```Python
array20[::-2, ::-2]
```

輸出：

```
array([[9, 7],
       [3, 1]])
```

關於陣列的索引和切片運算，大家可以透過下面的兩張圖來增強印象，這兩張圖來自[《利用Python進行資料分析》](https://item.jd.com/12398725.html)一書，它是 pandas 庫的作者 Wes McKinney 撰寫的 Python 資料分析領域的經典教科書，有興趣的讀者可以購買和閱讀原書。

圖1：二維陣列的普通索引

<img src="res/ndarray-index.png" style="zoom:60%;">

圖2：二維陣列的切片索引

<img src="res/ndarray-slice.png" style="zoom:60%;">

#### 花式索引

花式索引是用儲存整數的陣列充當一個陣列的索引，這裡所說的陣列可以是 NumPy 的`ndarray`，也可以是 Python 中`list`、`tuple`等可迭代型別，可以使用正向或負向索引。

程式碼：

```Python
array19[[0, 1, 1, -1, 4, -1]]
```

輸出：

```
array([1, 2, 2, 9, 5, 9])
```

程式碼：

```Python
array20[[0, 2]]
```

輸出：

```
array([[1, 2, 3],
       [7, 8, 9]])
```

程式碼：

```Python
array20[[0, 2], [1, 2]]
```

輸出：

```
array([2, 9])
```

程式碼：

```Python
array20[[0, 2], 1]
```

輸出：

```
array([2, 8])
```

#### 布林索引

布林索引就是透過儲存布林值的陣列充當一個陣列的索引，布林值為`True`的元素保留，布林值為`False`的元素不會被選中。布林值的陣列可以手動構造，也可以透過關係運算來產生。

程式碼：

```Python
array19[[True, True, False, False, True, False, False, True, True]]
```

輸出：

```
array([1, 2, 5, 8, 9])
```

程式碼：

```Python
array19 > 5
```

輸出：

```
array([False, False, False, False, False,  True,  True,  True,  True])
```

程式碼：

```Python
~(array19 > 5)
```

輸出：

```
array([ True,  True,  True,  True,  True, False, False, False, False])
```

> **說明**：`~`運算子可以對布林陣列中的布林值進行邏輯取反，也就是原來的`True`會變成`False`，原來的`False`會變成`True`。

程式碼：

```Python
array19[array19 > 5]
```

輸出：

```
array([6, 7, 8, 9])
```

程式碼：

```Python
array19 % 2 == 0
```

輸出：

```
array([False,  True, False,  True, False,  True, False,  True, False])
```

程式碼：

```Python
array19[array19 % 2 == 0]
```

輸出：

```
array([2, 4, 6, 8])
```

程式碼：

```Python
(array19 > 5) & (array19 % 2 == 0)
```

輸出：

```
array([False, False, False, False, False,  True, False,  True, False])
```

> **說明**：`&`運算子可以作用於兩個布林陣列，如果兩個陣列對應元素都是`True`，那麼運算的結果就是`True`，否則就是`False`，該運算子的運算規則類似於 Python 中的 `and` 運算子，只不過作用的物件是兩個布林陣列。

程式碼：

```Python
array19[(array19 > 5) & (array19 % 2 == 0)]
```

輸出：

```
array([6, 8])
```

程式碼：

```Python
array19[(array19 > 5) | (array19 % 2 == 0)]
```

輸出：

```
array([2, 4, 6, 7, 8, 9])
```

> **說明**：`|`運算子可以作用於兩個布林陣列，如果兩個陣列對應元素都是`False`，那麼運算的結果就是`False`，否則就是`True`，該運算子的運算規則類似於 Python 中的 `or` 運算子，只不過作用的物件是兩個布林陣列。

程式碼：

```Python
array20[array21 % 2 != 0]
```

輸出：

```
array([1, 3, 5, 7, 9])
```

關於索引運算需要說明的是，切片索引雖然建立了新的陣列物件，但是新陣列和原陣列共享了陣列中的資料，簡單的說，無論你透過新陣列物件或原陣列物件修改陣列中的資料，修改的其實是記憶體中的同一塊資料。花式索引和布林索引也會建立新的陣列物件，而且新陣列複製了原陣列的元素，新陣列和原陣列並不是共享資料的關係，這一點可以檢視陣列物件的`base`屬性，有興趣的讀者可以自行探索。

### 案例：透過陣列切片處理影象

學習基礎知識總是比較枯燥且沒有成就感的，所以我們還是來個案例為大家演示下上面學習的陣列索引和切片操作到底有什麼用。前面我們說到過，可以用三維陣列來表示影象，那麼透過影象對應的三維陣列進行操作，就可以實現對影象的處理，如下所示。

讀入圖片建立三維陣列物件。

```Python
guido_image = plt.imread('guido.jpg')
plt.imshow(guido_image)
```

<img src="res/guido_slice_1.png" style="zoom:65%;">

對陣列的0軸進行反向切片，實現影象的垂直翻轉。

```Python
plt.imshow(guido_image[::-1])
```

<img src="res/guido_slice_2.png" style="zoom:65%;">

對陣列的1軸進行反向切片，實現影象的水平翻轉。

```Python
plt.imshow(guido_image[:,::-1])
```

<img src="res/guido_slice_3.png" style="zoom:65%;">

透過切片操作實現摳圖，將吉多大叔的頭摳出來。

```Python
plt.imshow(guido_image[30:350, 90:300])
```

<img src="res/guido_slice_4.png" style="zoom:65%;">

透過切片操作實現降取樣。

```Python
plt.imshow(guido_image[::10, ::10])
```

<img src="res/guido_slice_5.png" style="zoom:65%;">

