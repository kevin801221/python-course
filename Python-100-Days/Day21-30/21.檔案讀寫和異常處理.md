## 檔案讀寫和異常處理

實際開發中常常會遇到對資料進行持久化的場景，所謂持久化是指將資料從無法長久儲存資料的儲存介質（通常是記憶體）轉移到可以長久儲存資料的儲存介質（通常是硬碟）中。實現資料持久化最直接簡單的方式就是透過**檔案系統**將資料儲存到**檔案**中。

計算機的**檔案系統**是一種儲存和組織計算機資料的方法，它使得對資料的訪問和查詢變得容易，檔案系統使用**檔案**和**樹形目錄**的抽象邏輯概念代替了硬碟、光碟、快閃記憶體等物理裝置的資料塊概念，使用者使用檔案系統來儲存資料時，不必關心資料實際儲存在硬碟的哪個資料塊上，只需要記住這個檔案的路徑和檔名。在寫入新資料之前，使用者不必關心硬碟上的哪個資料塊沒有被使用，硬碟上的儲存空間管理（分配和釋放）功能由檔案系統自動完成，使用者只需要記住資料被寫入到了哪個檔案中。

### 開啟和關閉檔案

有了檔案系統，我們可以非常方便的透過檔案來讀寫資料；在Python中要實現檔案操作是非常簡單的。我們可以使用Python內建的`open`函式來開啟檔案，在使用`open`函式時，我們可以透過函式的引數指定**檔名**、**操作模式**和**字元編碼**等資訊，接下來就可以對檔案進行讀寫操作了。這裡所說的操作模式是指要開啟什麼樣的檔案（字元檔案或二進位制檔案）以及做什麼樣的操作（讀、寫或追加），具體如下表所示。

| 操作模式 | 具體含義                         |
| -------- | -------------------------------- |
| `'r'`    | 讀取 （預設）                    |
| `'w'`    | 寫入（會先截斷之前的內容）       |
| `'x'`    | 寫入，如果檔案已經存在會產生異常 |
| `'a'`    | 追加，將內容寫入到已有檔案的末尾 |
| `'b'`    | 二進位制模式                       |
| `'t'`    | 文字模式（預設）                 |
| `'+'`    | 更新（既可以讀又可以寫）         |

下圖展示瞭如何根據程式的需要來設定`open`函式的操作模式。

<img src="res/20210803201644.png" width="75%">

在使用`open`函式時，如果開啟的檔案是字元檔案（文字檔案），可以透過`encoding`引數來指定讀寫檔案使用的字元編碼。如果對字元編碼和字符集這些概念不瞭解，可以看看[《字符集和字元編碼》](https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html)一文，此處不再進行贅述。

使用`open`函式開啟檔案成功後會返回一個檔案物件，透過這個物件，我們就可以實現對檔案的讀寫操作；如果開啟檔案失敗，`open`函式會引發異常，稍後會對此加以說明。如果要關閉開啟的檔案，可以使用檔案物件的`close`方法，這樣可以在結束檔案操作時釋放掉這個檔案。

### 讀寫文字檔案

用`open`函式開啟文字檔案時，需要指定檔名並將檔案的操作模式設定為`'r'`，如果不指定，預設值也是`'r'`；如果需要指定字元編碼，可以傳入`encoding`引數，如果不指定，預設值是None，那麼在讀取檔案時使用的是作業系統預設的編碼。需要提醒大家，如果不能保證儲存檔案時使用的編碼方式與`encoding`引數指定的編碼方式是一致的，那麼就可能因無法解碼字元而導致讀取檔案失敗。

下面的例子演示瞭如何讀取一個純文字檔案（一般指只有字元原生編碼構成的檔案，與富文字相比，純文字不包含字元樣式的控制元素，能夠被最簡單的文字編輯器直接讀取）。

```python
file = open('致橡樹.txt', 'r', encoding='utf-8')
print(file.read())
file.close()
```

> **說明**：[《致橡樹》](http://www.china.org.cn/learning_english/2011-02/21/content_21967654.htm)是舒婷老師在1977年3月建立的愛情詩，也是我最喜歡的現代詩之一。

除了使用檔案物件的`read`方法讀取檔案之外，還可以使用`for-in`迴圈逐行讀取或者用`readlines`方法將檔案按行讀取到一個列表容器中，程式碼如下所示。

```python
file = open('致橡樹.txt', 'r', encoding='utf-8')
for line in file:
    print(line, end='')
file.close()

file = open('致橡樹.txt', 'r', encoding='utf-8')
lines = file.readlines()
for line in lines:
    print(line, end='')
file.close()
```

如果要向檔案中寫入內容，可以在開啟檔案時使用`w`或者`a`作為操作模式，前者會截斷之前的文字內容寫入新的內容，後者是在原來內容的尾部追加新的內容。

```python
file = open('致橡樹.txt', 'a', encoding='utf-8')
file.write('\n標題：《致橡樹》')
file.write('\n作者：舒婷')
file.write('\n時間：1977年3月')
file.close()
```

### 異常處理機制

請注意上面的程式碼，如果`open`函式指定的檔案並不存在或者無法開啟，那麼將引發異常狀況導致程式崩潰。為了讓程式碼具有健壯性和容錯性，我們可以**使用Python的異常機制對可能在執行時發生狀況的程式碼進行適當的處理**。Python中和異常相關的關鍵字有五個，分別是`try`、`except`、`else`、`finally`和`raise`，我們先看看下面的程式碼，再來為大家介紹這些關鍵字的用法。

```python
file = None
try:
    file = open('致橡樹.txt', 'r', encoding='utf-8')
    print(file.read())
except FileNotFoundError:
    print('無法開啟指定的檔案!')
except LookupError:
    print('指定了未知的編碼!')
except UnicodeDecodeError:
    print('讀取檔案時解碼錯誤!')
finally:
    if file:
        file.close()
```

在Python中，我們可以將執行時會出現狀況的程式碼放在`try`程式碼塊中，在`try`後面可以跟上一個或多個`except`塊來捕獲異常並進行相應的處理。例如，在上面的程式碼中，檔案找不到會引發`FileNotFoundError`，指定了未知的編碼會引發`LookupError`，而如果讀取檔案時無法按指定編碼方式解碼檔案會引發`UnicodeDecodeError`，所以我們在`try`後面跟上了三個`except`分別處理這三種不同的異常狀況。在`except`後面，我們還可以加上`else`程式碼塊，這是`try` 中的程式碼沒有出現異常時會執行的程式碼，而且`else`中的程式碼不會再進行異常捕獲，也就是說如果遇到異常狀況，程式會因異常而終止並報告異常資訊。最後我們使用`finally`程式碼塊來關閉開啟的檔案，釋放掉程式中獲取的外部資源。由於`finally`塊的程式碼不論程式正常還是異常都會執行，甚至是呼叫了`sys`模組的`exit`函式終止Python程式，`finally`塊中的程式碼仍然會被執行（因為`exit`函式的本質是引發了`SystemExit`異常），因此我們把`finally`程式碼塊稱為“總是執行程式碼塊”，它最適合用來做釋放外部資源的操作。

Python中內建了大量的異常型別，除了上面程式碼中用到的異常型別以及之前的課程中遇到過的異常型別外，還有許多的異常型別，其繼承結構如下所示。

```
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```

從上面的繼承結構可以看出，Python中所有的異常都是`BaseException`的子型別，它有四個直接的子類，分別是：`SystemExit`、`KeyboardInterrupt`、`GeneratorExit`和`Exception`。其中，`SystemExit`表示直譯器請求退出，`KeyboardInterrupt`是使用者中斷程式執行（按下`Ctrl+c`），`GeneratorExit`表示生成器發生異常通知退出，不理解這些異常沒有關係，繼續學習就好了。值得一提的是`Exception`類，它是常規異常型別的父型別，很多的異常都是直接或間接的繼承自`Exception`類。如果Python內建的異常型別不能滿足應用程式的需要，我們可以自定義異常型別，而自定義的異常型別也應該直接或間接繼承自`Exception`類，當然還可以根據需要重寫或新增方法。

在Python中，可以使用`raise`關鍵字來引發異常（丟擲異常物件），而呼叫者可以透過`try...except...`結構來捕獲並處理異常。例如在函式中，當函式的執行條件不滿足時，可以使用丟擲異常的方式來告知呼叫者問題的所在，而呼叫者可以透過捕獲處理異常來使得程式碼從異常中恢復，定義異常和丟擲異常的程式碼如下所示。

```python
class InputError(ValueError):
    """自定義異常型別"""
    pass


def fac(num):
    """求階乘"""
    if num < 0:
        raise InputError('只能計算非負整數的階乘')
    if num in (0, 1):
        return 1
    return num * fac(num - 1)
```

呼叫求階乘的函式`fac`，透過`try...except...`結構捕獲輸入錯誤的異常並列印異常物件（顯示異常資訊），如果輸入正確就計算階乘並結束程式。

```python
flag = True
while flag:
    num = int(input('n = '))
    try:
        print(f'{num}! = {fac(num)}')
        flag = False
    except InputError as err:
        print(err)
```

### 上下文管理器語法

對於`open`函式返回的檔案物件，還可以使用`with`上下文管理器語法在檔案操作完成後自動執行檔案物件的`close`方法，這樣可以讓程式碼變得更加簡單優雅，因為不需要再寫`finally`程式碼塊來執行關閉檔案釋放資源的操作。需要提醒大家的是，並不是所有的物件都可以放在`with`上下文語法中，只有符合**上下文管理器協議**（有`__enter__`和`__exit__`魔術方法）的物件才能使用這種語法，Python標準庫中的`contextlib`模組也提供了對`with`上下文語法的支援，後面再為大家進行講解。

用`with`上下文語法改寫後的程式碼如下所示。

```python
try:
    with open('致橡樹.txt', 'r', encoding='utf-8') as file:
        print(file.read())
except FileNotFoundError:
    print('無法開啟指定的檔案!')
except LookupError:
    print('指定了未知的編碼!')
except UnicodeDecodeError:
    print('讀取檔案時解碼錯誤!')
```

### 讀寫二進位制檔案

讀寫二進位制檔案跟讀寫文字檔案的操作類似，但是需要注意，在使用`open`函式開啟檔案時，如果要進行讀操作，操作模式是`'rb'`，如果要進行寫操作，操作模式是`'wb'`。還有一點，讀寫文字檔案時，`read`方法的返回值以及`write`方法的引數是`str`物件（字串），而讀寫二進位制檔案時，`read`方法的返回值以及`write`方法的引數是`bytes-like`物件（位元組串）。下面的程式碼實現了將當前路徑下名為`guido.jpg`的圖片檔案複製到`吉多.jpg`檔案中的操作。

```python
try:
    with open('guido.jpg', 'rb') as file1:
        data = file1.read()
    with open('吉多.jpg', 'wb') as file2:
        file2.write(data)
except FileNotFoundError:
    print('指定的檔案無法開啟.')
except IOError:
    print('讀寫檔案時出現錯誤.')
print('程式執行結束.')
```

如果要複製的圖片檔案很大，一次將檔案內容直接讀入記憶體中可能會造成非常大的記憶體開銷，為了減少對記憶體的佔用，可以為`read`方法傳入`size`引數來指定每次讀取的位元組數，透過迴圈讀取和寫入的方式來完成上面的操作，程式碼如下所示。

```python
try:
    with open('guido.jpg', 'rb') as file1, open('吉多.jpg', 'wb') as file2:
        data = file1.read(512)
        while data:
            file2.write(data)
            data = file1.read()
except FileNotFoundError:
    print('指定的檔案無法開啟.')
except IOError:
    print('讀寫檔案時出現錯誤.')
print('程式執行結束.')
```

###  總結

透過讀寫檔案的操作，我們可以實現資料持久化。在Python中可以透過`open`函式來獲得檔案物件，可以透過檔案物件的`read`和`write`方法實現檔案讀寫操作。程式在執行時可能遭遇無法預料的異常狀況，可以使用Python的異常機制來處理這些狀況。Python的異常機制主要包括`try`、`except`、`else`、`finally`和`raise`這五個核心關鍵字。`try`後面的`except`語句不是必須的，`finally`語句也不是必須的，但是二者必須要有一個；`except`語句可以有一個或多個，多個`except`會按照書寫的順序依次匹配指定的異常，如果異常已經處理就不會再進入後續的`except`語句；`except`語句中還可以透過元組同時指定多個異常型別進行捕獲；`except`語句後面如果不指定異常型別，則預設捕獲所有異常；捕獲異常後可以使用`raise`要再次丟擲，但是不建議捕獲並丟擲同一個異常；不建議在不清楚邏輯的情況下捕獲所有異常，這可能會掩蓋程式中嚴重的問題。最後強調一點，**不要使用異常機制來處理正常業務邏輯或控制程式流程**，簡單的說就是不要濫用異常機制，這是初學者常犯的錯誤。
