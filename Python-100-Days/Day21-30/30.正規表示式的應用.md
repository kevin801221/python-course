## 正規表示式的應用

### 正規表示式相關知識

在編寫處理字串的程式時，經常會遇到在一段文字中查詢符合某些規則的字串的需求，正規表示式就是用於描述這些規則的工具，換句話說，我們可以使用正規表示式來定義字串的匹配模式，即如何檢查一個字串是否有跟某種模式匹配的部分或者從一個字串中將與模式匹配的部分提取出來或者替換掉。

舉一個簡單的例子，如果你在 Windows 作業系統中使用過檔案查詢並且在指定檔名時使用過萬用字元（`*`和`?`），那麼正規表示式也是與之類似的用 來進行文字匹配的工具，只不過比起萬用字元正規表示式更強大，它能更精確地描述你的需求，當然你付出的代價是書寫一個正規表示式比使用萬用字元要複雜得多，因為任何給你帶來好處的東西都需要你付出對應的代價。

再舉一個例子，我們從某個地方（可能是一個文字檔案，也可能是網路上的一則新聞）獲得了一個字串，希望在字串中找出手機號和座機號。當然我們可以設定手機號是 11 位的數字（注意並不是隨機的 11 位數字，因為你沒有見過“25012345678”這樣的手機號），而座機號則是類似於“區號-號碼”這樣的模式，如果不使用正規表示式要完成這個任務就會比較麻煩。最初計算機是為了做數學運算而誕生的，處理的資訊基本上都是數值，而今天我們在日常工作中處理的資訊很多都是文字資料，我們希望計算機能夠識別和處理符合某些模式的文字，正規表示式就顯得非常重要了。今天幾乎所有的程式語言都提供了對正規表示式操作的支援，Python 透過標準庫中的`re`模組來支援正規表示式操作。

關於正規表示式的相關知識，大家可以閱讀一篇非常有名的博文叫[《正規表示式30分鐘入門教程》](https://deerchao.net/tutorials/regex/regex.htm)，讀完這篇文章後你就可以看懂下面的表格，這是我們對正規表示式中的一些基本符號進行的扼要總結。

| 符號           | 解釋                             | 示例               | 說明                                                         |
| -------------- | -------------------------------- | ------------------ | ------------------------------------------------------------ |
| `.`            | 匹配任意字元                     | `b.t`              | 可以匹配bat / but / b#t / b1t等                              |
| `\w`           | 匹配字母/數字/下劃線             | `b\wt`             | 可以匹配bat / b1t / b_t等<br>但不能匹配b#t                   |
| `\s`           | 匹配空白字元（包括\r、\n、\t等） | `love\syou`        | 可以匹配love you                                             |
| `\d`           | 匹配數字                         | `\d\d`             | 可以匹配01 / 23 / 99等                                       |
| `\b`           | 匹配單詞的邊界                   | `\bThe\b`          |                                                              |
| `^`            | 匹配字串的開始                 | `^The`             | 可以匹配The開頭的字串                                      |
| `$`            | 匹配字串的結束                 | `.exe$`            | 可以匹配.exe結尾的字串                                     |
| `\W`           | 匹配非字母/數字/下劃線           | `b\Wt`             | 可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等           |
| `\S`           | 匹配非空白字元                   | `love\Syou`        | 可以匹配love#you等<br>但不能匹配love you                     |
| `\D`           | 匹配非數字                       | `\d\D`             | 可以匹配9a / 3# / 0F等                                       |
| `\B`           | 匹配非單詞邊界                   | `\Bio\B`           |                                                              |
| `[]`           | 匹配來自字符集的任意單一字元     | `[aeiou]`          | 可以匹配任一母音字母字元                                     |
| `[^]`          | 匹配不在字符集中的任意單一字元   | `[^aeiou]`         | 可以匹配任一非母音字母字元                                   |
| `*`            | 匹配0次或多次                    | `\w*`              |                                                              |
| `+`            | 匹配1次或多次                    | `\w+`              |                                                              |
| `?`            | 匹配0次或1次                     | `\w?`              |                                                              |
| `{N}`          | 匹配N次                          | `\w{3}`            |                                                              |
| `{M,}`         | 匹配至少M次                      | `\w{3,}`           |                                                              |
| `{M,N}`        | 匹配至少M次至多N次               | `\w{3,6}`          |                                                              |
| `\|`            | 分支                             | `foo\|bar`          | 可以匹配foo或者bar                                           |
| `(?#)`         | 註釋                             |                    |                                                              |
| `(exp)`        | 匹配exp並捕獲到自動命名的組中    |                    |                                                              |
| `(?<name>exp)` | 匹配exp並捕獲到名為name的組中    |                    |                                                              |
| `(?:exp)`      | 匹配exp但是不捕獲匹配的文字      |                    |                                                              |
| `(?=exp)`      | 匹配exp前面的位置                | `\b\w+(?=ing)`     | 可以匹配I'm dancing中的danc                                  |
| `(?<=exp)`     | 匹配exp後面的位置                | `(?<=\bdanc)\w+\b` | 可以匹配I love dancing and reading中的第一個ing              |
| `(?!exp)`      | 匹配後面不是exp的位置            |                    |                                                              |
| `(?<!exp)`     | 匹配前面不是exp的位置            |                    |                                                              |
| `*?`           | 重複任意次，但儘可能少重複       | `a.*b`<br>`a.*?b`  | 將正規表示式應用於aabab，前者會匹配整個字串aabab，後者會匹配aab和ab兩個字串 |
| `+?`           | 重複1次或多次，但儘可能少重複    |                    |                                                              |
| `??`           | 重複0次或1次，但儘可能少重複     |                    |                                                              |
| `{M,N}?`       | 重複M到N次，但儘可能少重複       |                    |                                                              |
| `{M,}?`        | 重複M次以上，但儘可能少重複      |                    |                                                              |

> **說明：** 如果需要匹配的字元是正規表示式中的特殊字元，那麼可以使用`\`進行轉義處理，例如想匹配小數點可以寫成`\.`就可以了，因為直接寫`.`會匹配任意字元；同理，想匹配圓括號必須寫成`\(`和`\)`，否則圓括號被視為正規表示式中的分組。

### Python對正規表示式的支援

Python 提供了`re`模組來支援正規表示式相關操作，下面是`re`模組中的核心函式。

| 函式                                           | 說明                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| `compile(pattern, flags=0)`                    | 編譯正規表示式返回正規表示式物件                             |
| `match(pattern, string, flags=0)`              | 用正規表示式匹配字串 成功返回匹配物件 否則返回`None`       |
| `search(pattern, string, flags=0)`             | 搜尋字串中第一次出現正規表示式的模式 成功返回匹配物件 否則返回`None` |
| `split(pattern, string, maxsplit=0, flags=0)`  | 用正規表示式指定的模式分隔符拆分字串 返回列表              |
| `sub(pattern, repl, string, count=0, flags=0)` | 用指定的字串替換原字串中與正規表示式匹配的模式 可以用`count`指定替換的次數 |
| `fullmatch(pattern, string, flags=0)`          | `match`函式的完全匹配（從字串開頭到結尾）版本              |
| `findall(pattern, string, flags=0)`            | 查詢字串所有與正規表示式匹配的模式 返回字串的列表        |
| `finditer(pattern, string, flags=0)`           | 查詢字串所有與正規表示式匹配的模式 返回一個迭代器          |
| `purge()`                                      | 清除隱式編譯的正規表示式的快取                               |
| `re.I` / `re.IGNORECASE`                       | 忽略大小寫匹配標記                                           |
| `re.M` / `re.MULTILINE`                        | 多行匹配標記                                                 |

> **說明：** 上面提到的`re`模組中的這些函式，實際開發中也可以用正規表示式物件（`Pattern`物件）的方法替代對這些函式的使用，如果一個正規表示式需要重複的使用，那麼先透過`compile`函式編譯正規表示式並建立出正規表示式物件無疑是更為明智的選擇。

下面我們透過一系列的例子來告訴大家在Python中如何使用正規表示式。

#### 例子1：驗證輸入使用者名稱和QQ號是否有效並給出對應的提示資訊。

```python
"""
要求：使用者名稱必須由字母、數字或下劃線構成且長度在6~20個字元之間，QQ號是5~12的數字且首位不能為0
"""
import re

username = input('請輸入使用者名稱: ')
qq = input('請輸入QQ號: ')
# match函式的第一個引數是正規表示式字串或正規表示式物件
# match函式的第二個引數是要跟正規表示式做匹配的字串物件
m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username)
if not m1:
    print('請輸入有效的使用者名稱.')
# fullmatch函式要求字串和正規表示式完全匹配
# 所以正規表示式沒有寫起始符和結束符
m2 = re.fullmatch(r'[1-9]\d{4,11}', qq)
if not m2:
    print('請輸入有效的QQ號.')
if m1 and m2:
    print('你輸入的資訊是有效的!')
```

> **提示：** 上面在書寫正規表示式時使用了“原始字串”的寫法（在字串前面加上了`r`），所謂“原始字串”就是字串中的每個字元都是它原始的意義，說得更直接一點就是字串中沒有所謂的跳脫字元啦。因為正規表示式中有很多元字元和需要進行轉義的地方，如果不使用原始字串就需要將反斜槓寫作`\\`，例如表示數字的`\d`得書寫成`\\d`，這樣不僅寫起來不方便，閱讀的時候也會很吃力。

#### 例子2：從一段文字中提取出國內手機號碼。

下面這張圖是截止到 2017 年底，國內三家運營商推出的手機號段。

<img src="res/20210803203134.png" style="zoom:100%;">

```python
import re

# 建立正規表示式物件，使用了前瞻和回顧來保證手機號前後不應該再出現數字
pattern = re.compile(r'(?<=\D)1[34578]\d{9}(?=\D)')
sentence = '''重要的事情說8130123456789遍，我的手機號是13512346789這個靚號，
不是15600998765，也不是110或119，王大錘的手機號才是15600998765。'''
# 方法一：查詢所有匹配並儲存到一個列表中
tels_list = re.findall(pattern, sentence)
for tel in tels_list:
    print(tel)
print('--------華麗的分隔線--------')

# 方法二：透過迭代器取出匹配物件並獲得匹配的內容
for temp in pattern.finditer(sentence):
    print(temp.group())
print('--------華麗的分隔線--------')

# 方法三：透過search函式指定搜尋位置找出所有匹配
m = pattern.search(sentence)
while m:
    print(m.group())
    m = pattern.search(sentence, m.end())
```

> **說明：** 上面匹配國內手機號的正規表示式並不夠好，因為像 14 開頭的號碼只有 145 或 147，而上面的正規表示式並沒有考慮這種情況，要匹配國內手機號，更好的正規表示式的寫法是：`(?<=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)`，國內好像已經有 19 和 16 開頭的手機號了，但是這個暫時不在我們考慮之列。

#### 例子3：替換字串中的不良內容

```python
import re

sentence = 'Oh, shit! 你是傻逼嗎? Fuck you.'
purified = re.sub('fuck|shit|[傻煞沙][比筆逼叉缺吊碉雕]',
                  '*', sentence, flags=re.IGNORECASE)
print(purified)  # Oh, *! 你是*嗎? * you.
```

> **說明：**` re`模組的正規表示式相關函式中都有一個`flags`引數，它代表了正規表示式的匹配標記，可以透過該標記來指定匹配時是否忽略大小寫、是否進行多行匹配、是否顯示除錯資訊等。如果需要為`flags`引數指定多個值，可以使用[按位或運算子](http://www.runoob.com/python/python-operators.html#ysf5)進行疊加，如`flags=re.I | re.M`。

#### 例子4：拆分長字串

```python
import re

poem = '窗前明月光，疑是地上霜。舉頭望明月，低頭思故鄉。'
sentences_list = re.split(r'[，。]', poem)
sentences_list = [sentence for sentence in sentences_list if sentence]
for sentence in sentences_list:
    print(sentence)
```

###  總結

正規表示式在字串的處理和匹配上真的非常強大，透過上面的例子相信大家已經感受到了正規表示式的魅力，當然寫一個正規表示式對新手來說並不是那麼容易，但是很多事情都是熟能生巧，大膽的去嘗試就行了，有一個線上的[正規表示式測試工具](https://c.runoob.com/front-end/854)相信能夠在一定程度上幫到大家。
